\section{bitmap.\+h}
\label{direct_2bitmap_8h_source}\index{graph/direct/bitmap.\+h@{graph/direct/bitmap.\+h}}

\begin{DoxyCode}
00001 
00011 \textcolor{preprocessor}{#ifndef BITMAP\_H\_}
00012 \textcolor{preprocessor}{#define BITMAP\_H\_}
00013 
00014 \textcolor{preprocessor}{#include <stdlib.h>}
00015 \textcolor{preprocessor}{#include <stddef.h>}
00016 \textcolor{preprocessor}{#include <stdio.h>}
00017 \textcolor{preprocessor}{#include <string.h>}
00018 \textcolor{preprocessor}{#include <stdint.h>}
00019 
00021 \textcolor{preprocessor}{#ifdef \_ARCH256\_}
00022 \textcolor{preprocessor}{#include <immintrin.h>}\textcolor{comment}{//AVX}
00023 
00024 \textcolor{keyword}{typedef} \textcolor{keyword}{union }\{
00025     \_\_m256d md;
00026     \_\_m256i mi;
00027     \textcolor{keywordtype}{double} d64;
00028     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} ui64[4];
00029 \} NODETYPE; 
00030 
00031 \textcolor{keyword}{static} \textcolor{keyword}{const} NODETYPE \_\_zero = \{ .ui64 = \{ 0, 0, 0, 0 \} \};
00032 
00033 \textcolor{preprocessor}{#define BSIZE 256}
00034 \textcolor{preprocessor}{#define WSIZE 32}
00035 \textcolor{preprocessor}{#define LOGB 8LL}
00036 \textcolor{preprocessor}{#define LOGW 5}
00037 \textcolor{preprocessor}{#define LOGBW 13}
00038 
00039 \textcolor{preprocessor}{#define ONE 1LL}
00040 \textcolor{preprocessor}{#define NODEMAX 0xFFFFFFFFFFFFFFFF}
00041 \textcolor{preprocessor}{#define MASKB 0xFFLL}
00042 \textcolor{comment}{//#define MASKB 0xFFFFFFFFFFFFFFC0}
00043 
00044 \textcolor{preprocessor}{#define MASKSZ (BSIZE+1)}
00045 \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \_\_mask[MASKSZ] = \{
00046         0xFFFFFFFFFFFFFFFF,
00047         0xFFFFFFFFFFFFFFFE, 0xFFFFFFFFFFFFFFFC, 0xFFFFFFFFFFFFFFF8, 0xFFFFFFFFFFFFFFF0,
00048         0xFFFFFFFFFFFFFFE0, 0xFFFFFFFFFFFFFFC0, 0xFFFFFFFFFFFFFF80, 0xFFFFFFFFFFFFFF00,
00049         0xFFFFFFFFFFFFFE00, 0xFFFFFFFFFFFFFC00, 0xFFFFFFFFFFFFF800, 0xFFFFFFFFFFFFF000,
00050         0xFFFFFFFFFFFFE000, 0xFFFFFFFFFFFFC000, 0xFFFFFFFFFFFF8000, 0xFFFFFFFFFFFF0000,
00051         0xFFFFFFFFFFFE0000, 0xFFFFFFFFFFFC0000, 0xFFFFFFFFFFF80000, 0xFFFFFFFFFFF00000,
00052         0xFFFFFFFFFFE00000, 0xFFFFFFFFFFC00000, 0xFFFFFFFFFF800000, 0xFFFFFFFFFF000000,
00053         0xFFFFFFFFFE000000, 0xFFFFFFFFFC000000, 0xFFFFFFFFF8000000, 0xFFFFFFFFF0000000,
00054         0xFFFFFFFFE0000000, 0xFFFFFFFFC0000000, 0xFFFFFFFF80000000, 0xFFFFFFFF00000000,
00055         0xFFFFFFFE00000000, 0xFFFFFFFC00000000, 0xFFFFFFF800000000, 0xFFFFFFF000000000,
00056         0xFFFFFFE000000000, 0xFFFFFFC000000000, 0xFFFFFF8000000000, 0xFFFFFF0000000000,
00057         0xFFFFFE0000000000, 0xFFFFFC0000000000, 0xFFFFF80000000000, 0xFFFFF00000000000,
00058         0xFFFFE00000000000, 0xFFFFC00000000000, 0xFFFF800000000000, 0xFFFF000000000000,
00059         0xFFFE000000000000, 0xFFFC000000000000, 0xFFF8000000000000, 0xFFF0000000000000,
00060         0xFFE0000000000000, 0xFFC0000000000000, 0xFF80000000000000, 0xFF00000000000000,
00061         0xFE00000000000000, 0xFC00000000000000, 0xF800000000000000, 0xF000000000000000,
00062         0xE000000000000000, 0xC000000000000000, 0x8000000000000000, 0xFFFFFFFFFFFFFFFF,
00063         0xFFFFFFFFFFFFFFFE, 0xFFFFFFFFFFFFFFFC, 0xFFFFFFFFFFFFFFF8, 0xFFFFFFFFFFFFFFF0,
00064         0xFFFFFFFFFFFFFFE0, 0xFFFFFFFFFFFFFFC0, 0xFFFFFFFFFFFFFF80, 0xFFFFFFFFFFFFFF00,
00065         0xFFFFFFFFFFFFFE00, 0xFFFFFFFFFFFFFC00, 0xFFFFFFFFFFFFF800, 0xFFFFFFFFFFFFF000,
00066         0xFFFFFFFFFFFFE000, 0xFFFFFFFFFFFFC000, 0xFFFFFFFFFFFF8000, 0xFFFFFFFFFFFF0000,
00067         0xFFFFFFFFFFFE0000, 0xFFFFFFFFFFFC0000, 0xFFFFFFFFFFF80000, 0xFFFFFFFFFFF00000,
00068         0xFFFFFFFFFFE00000, 0xFFFFFFFFFFC00000, 0xFFFFFFFFFF800000, 0xFFFFFFFFFF000000,
00069         0xFFFFFFFFFE000000, 0xFFFFFFFFFC000000, 0xFFFFFFFFF8000000, 0xFFFFFFFFF0000000,
00070         0xFFFFFFFFE0000000, 0xFFFFFFFFC0000000, 0xFFFFFFFF80000000, 0xFFFFFFFF00000000,
00071         0xFFFFFFFE00000000, 0xFFFFFFFC00000000, 0xFFFFFFF800000000, 0xFFFFFFF000000000,
00072         0xFFFFFFE000000000, 0xFFFFFFC000000000, 0xFFFFFF8000000000, 0xFFFFFF0000000000,
00073         0xFFFFFE0000000000, 0xFFFFFC0000000000, 0xFFFFF80000000000, 0xFFFFF00000000000,
00074         0xFFFFE00000000000, 0xFFFFC00000000000, 0xFFFF800000000000, 0xFFFF000000000000,
00075         0xFFFE000000000000, 0xFFFC000000000000, 0xFFF8000000000000, 0xFFF0000000000000,
00076         0xFFE0000000000000, 0xFFC0000000000000, 0xFF80000000000000, 0xFF00000000000000,
00077         0xFE00000000000000, 0xFC00000000000000, 0xF800000000000000, 0xF000000000000000,
00078         0xE000000000000000, 0xC000000000000000, 0x8000000000000000, 0xFFFFFFFFFFFFFFFF,
00079         0xFFFFFFFFFFFFFFFE, 0xFFFFFFFFFFFFFFFC, 0xFFFFFFFFFFFFFFF8, 0xFFFFFFFFFFFFFFF0,
00080         0xFFFFFFFFFFFFFFE0, 0xFFFFFFFFFFFFFFC0, 0xFFFFFFFFFFFFFF80, 0xFFFFFFFFFFFFFF00,
00081         0xFFFFFFFFFFFFFE00, 0xFFFFFFFFFFFFFC00, 0xFFFFFFFFFFFFF800, 0xFFFFFFFFFFFFF000,
00082         0xFFFFFFFFFFFFE000, 0xFFFFFFFFFFFFC000, 0xFFFFFFFFFFFF8000, 0xFFFFFFFFFFFF0000,
00083         0xFFFFFFFFFFFE0000, 0xFFFFFFFFFFFC0000, 0xFFFFFFFFFFF80000, 0xFFFFFFFFFFF00000,
00084         0xFFFFFFFFFFE00000, 0xFFFFFFFFFFC00000, 0xFFFFFFFFFF800000, 0xFFFFFFFFFF000000,
00085         0xFFFFFFFFFE000000, 0xFFFFFFFFFC000000, 0xFFFFFFFFF8000000, 0xFFFFFFFFF0000000,
00086         0xFFFFFFFFE0000000, 0xFFFFFFFFC0000000, 0xFFFFFFFF80000000, 0xFFFFFFFF00000000,
00087         0xFFFFFFFE00000000, 0xFFFFFFFC00000000, 0xFFFFFFF800000000, 0xFFFFFFF000000000,
00088         0xFFFFFFE000000000, 0xFFFFFFC000000000, 0xFFFFFF8000000000, 0xFFFFFF0000000000,
00089         0xFFFFFE0000000000, 0xFFFFFC0000000000, 0xFFFFF80000000000, 0xFFFFF00000000000,
00090         0xFFFFE00000000000, 0xFFFFC00000000000, 0xFFFF800000000000, 0xFFFF000000000000,
00091         0xFFFE000000000000, 0xFFFC000000000000, 0xFFF8000000000000, 0xFFF0000000000000,
00092         0xFFE0000000000000, 0xFFC0000000000000, 0xFF80000000000000, 0xFF00000000000000,
00093         0xFE00000000000000, 0xFC00000000000000, 0xF800000000000000, 0xF000000000000000,
00094         0xE000000000000000, 0xC000000000000000, 0x8000000000000000, 0xFFFFFFFFFFFFFFFF,
00095         0xFFFFFFFFFFFFFFFE, 0xFFFFFFFFFFFFFFFC, 0xFFFFFFFFFFFFFFF8, 0xFFFFFFFFFFFFFFF0,
00096         0xFFFFFFFFFFFFFFE0, 0xFFFFFFFFFFFFFFC0, 0xFFFFFFFFFFFFFF80, 0xFFFFFFFFFFFFFF00,
00097         0xFFFFFFFFFFFFFE00, 0xFFFFFFFFFFFFFC00, 0xFFFFFFFFFFFFF800, 0xFFFFFFFFFFFFF000,
00098         0xFFFFFFFFFFFFE000, 0xFFFFFFFFFFFFC000, 0xFFFFFFFFFFFF8000, 0xFFFFFFFFFFFF0000,
00099         0xFFFFFFFFFFFE0000, 0xFFFFFFFFFFFC0000, 0xFFFFFFFFFFF80000, 0xFFFFFFFFFFF00000,
00100         0xFFFFFFFFFFE00000, 0xFFFFFFFFFFC00000, 0xFFFFFFFFFF800000, 0xFFFFFFFFFF000000,
00101         0xFFFFFFFFFE000000, 0xFFFFFFFFFC000000, 0xFFFFFFFFF8000000, 0xFFFFFFFFF0000000,
00102         0xFFFFFFFFE0000000, 0xFFFFFFFFC0000000, 0xFFFFFFFF80000000, 0xFFFFFFFF00000000,
00103         0xFFFFFFFE00000000, 0xFFFFFFFC00000000, 0xFFFFFFF800000000, 0xFFFFFFF000000000,
00104         0xFFFFFFE000000000, 0xFFFFFFC000000000, 0xFFFFFF8000000000, 0xFFFFFF0000000000,
00105         0xFFFFFE0000000000, 0xFFFFFC0000000000, 0xFFFFF80000000000, 0xFFFFF00000000000,
00106         0xFFFFE00000000000, 0xFFFFC00000000000, 0xFFFF800000000000, 0xFFFF000000000000,
00107         0xFFFE000000000000, 0xFFFC000000000000, 0xFFF8000000000000, 0xFFF0000000000000,
00108         0xFFE0000000000000, 0xFFC0000000000000, 0xFF80000000000000, 0xFF00000000000000,
00109         0xFE00000000000000, 0xFC00000000000000, 0xF800000000000000, 0xF000000000000000,
00110         0xE000000000000000, 0xC000000000000000, 0x8000000000000000, 0x0000000000000000
00111 \};
00112 
00113 \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \_\_oneshifted[MASKSZ] = \{
00114         0x0000000000000001,
00115         0x0000000000000002, 0x0000000000000004, 0x0000000000000008, 0x0000000000000010,
00116         0x0000000000000020, 0x0000000000000040, 0x0000000000000080, 0x0000000000000100,
00117         0x0000000000000200, 0x0000000000000400, 0x0000000000000800, 0x0000000000001000,
00118         0x0000000000002000, 0x0000000000004000, 0x0000000000008000, 0x0000000000010000,
00119         0x0000000000020000, 0x0000000000040000, 0x0000000000080000, 0x0000000000100000,
00120         0x0000000000200000, 0x0000000000400000, 0x0000000000800000, 0x0000000001000000,
00121         0x0000000002000000, 0x0000000004000000, 0x0000000008000000, 0x0000000010000000,
00122         0x0000000020000000, 0x0000000040000000, 0x0000000080000000, 0x0000000100000000,
00123         0x0000000200000000, 0x0000000400000000, 0x0000000800000000, 0x0000001000000000,
00124         0x0000002000000000, 0x0000004000000000, 0x0000008000000000, 0x0000010000000000,
00125         0x0000020000000000, 0x0000040000000000, 0x0000080000000000, 0x0000100000000000,
00126         0x0000200000000000, 0x0000400000000000, 0x0000800000000000, 0x0001000000000000,
00127         0x0002000000000000, 0x0004000000000000, 0x0008000000000000, 0x0010000000000000,
00128         0x0020000000000000, 0x0040000000000000, 0x0080000000000000, 0x0100000000000000,
00129         0x0200000000000000, 0x0400000000000000, 0x0800000000000000, 0x1000000000000000,
00130         0x2000000000000000, 0x4000000000000000, 0x8000000000000000, 0x0000000000000001,
00131         0x0000000000000002, 0x0000000000000004, 0x0000000000000008, 0x0000000000000010,
00132         0x0000000000000020, 0x0000000000000040, 0x0000000000000080, 0x0000000000000100,
00133         0x0000000000000200, 0x0000000000000400, 0x0000000000000800, 0x0000000000001000,
00134         0x0000000000002000, 0x0000000000004000, 0x0000000000008000, 0x0000000000010000,
00135         0x0000000000020000, 0x0000000000040000, 0x0000000000080000, 0x0000000000100000,
00136         0x0000000000200000, 0x0000000000400000, 0x0000000000800000, 0x0000000001000000,
00137         0x0000000002000000, 0x0000000004000000, 0x0000000008000000, 0x0000000010000000,
00138         0x0000000020000000, 0x0000000040000000, 0x0000000080000000, 0x0000000100000000,
00139         0x0000000200000000, 0x0000000400000000, 0x0000000800000000, 0x0000001000000000,
00140         0x0000002000000000, 0x0000004000000000, 0x0000008000000000, 0x0000010000000000,
00141         0x0000020000000000, 0x0000040000000000, 0x0000080000000000, 0x0000100000000000,
00142         0x0000200000000000, 0x0000400000000000, 0x0000800000000000, 0x0001000000000000,
00143         0x0002000000000000, 0x0004000000000000, 0x0008000000000000, 0x0010000000000000,
00144         0x0020000000000000, 0x0040000000000000, 0x0080000000000000, 0x0100000000000000,
00145         0x0200000000000000, 0x0400000000000000, 0x0800000000000000, 0x1000000000000000,
00146         0x2000000000000000, 0x4000000000000000, 0x8000000000000000, 0x0000000000000001,
00147         0x0000000000000002, 0x0000000000000004, 0x0000000000000008, 0x0000000000000010,
00148         0x0000000000000020, 0x0000000000000040, 0x0000000000000080, 0x0000000000000100,
00149         0x0000000000000200, 0x0000000000000400, 0x0000000000000800, 0x0000000000001000,
00150         0x0000000000002000, 0x0000000000004000, 0x0000000000008000, 0x0000000000010000,
00151         0x0000000000020000, 0x0000000000040000, 0x0000000000080000, 0x0000000000100000,
00152         0x0000000000200000, 0x0000000000400000, 0x0000000000800000, 0x0000000001000000,
00153         0x0000000002000000, 0x0000000004000000, 0x0000000008000000, 0x0000000010000000,
00154         0x0000000020000000, 0x0000000040000000, 0x0000000080000000, 0x0000000100000000,
00155         0x0000000200000000, 0x0000000400000000, 0x0000000800000000, 0x0000001000000000,
00156         0x0000002000000000, 0x0000004000000000, 0x0000008000000000, 0x0000010000000000,
00157         0x0000020000000000, 0x0000040000000000, 0x0000080000000000, 0x0000100000000000,
00158         0x0000200000000000, 0x0000400000000000, 0x0000800000000000, 0x0001000000000000,
00159         0x0002000000000000, 0x0004000000000000, 0x0008000000000000, 0x0010000000000000,
00160         0x0020000000000000, 0x0040000000000000, 0x0080000000000000, 0x0100000000000000,
00161         0x0200000000000000, 0x0400000000000000, 0x0800000000000000, 0x1000000000000000,
00162         0x2000000000000000, 0x4000000000000000, 0x8000000000000000, 0x0000000000000001,
00163         0x0000000000000002, 0x0000000000000004, 0x0000000000000008, 0x0000000000000010,
00164         0x0000000000000020, 0x0000000000000040, 0x0000000000000080, 0x0000000000000100,
00165         0x0000000000000200, 0x0000000000000400, 0x0000000000000800, 0x0000000000001000,
00166         0x0000000000002000, 0x0000000000004000, 0x0000000000008000, 0x0000000000010000,
00167         0x0000000000020000, 0x0000000000040000, 0x0000000000080000, 0x0000000000100000,
00168         0x0000000000200000, 0x0000000000400000, 0x0000000000800000, 0x0000000001000000,
00169         0x0000000002000000, 0x0000000004000000, 0x0000000008000000, 0x0000000010000000,
00170         0x0000000020000000, 0x0000000040000000, 0x0000000080000000, 0x0000000100000000,
00171         0x0000000200000000, 0x0000000400000000, 0x0000000800000000, 0x0000001000000000,
00172         0x0000002000000000, 0x0000004000000000, 0x0000008000000000, 0x0000010000000000,
00173         0x0000020000000000, 0x0000040000000000, 0x0000080000000000, 0x0000100000000000,
00174         0x0000200000000000, 0x0000400000000000, 0x0000800000000000, 0x0001000000000000,
00175         0x0002000000000000, 0x0004000000000000, 0x0008000000000000, 0x0010000000000000,
00176         0x0020000000000000, 0x0040000000000000, 0x0080000000000000, 0x0100000000000000,
00177         0x0200000000000000, 0x0400000000000000, 0x0800000000000000, 0x1000000000000000,
00178         0x2000000000000000, 0x4000000000000000, 0x8000000000000000, 0x0000000000000000
00179 \};
00180 
00181 \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{char} \_\_index[MASKSZ] = \{
00182         0,
00183         0, 0, 0, 0,
00184         0, 0, 0, 0,
00185         0, 0, 0, 0,
00186         0, 0, 0, 0,
00187         0, 0, 0, 0,
00188         0, 0, 0, 0,
00189         0, 0, 0, 0,
00190         0, 0, 0, 0,
00191         0, 0, 0, 0,
00192         0, 0, 0, 0,
00193         0, 0, 0, 0,
00194         0, 0, 0, 0,
00195         0, 0, 0, 0,
00196         0, 0, 0, 0,
00197         0, 0, 0, 0,
00198         0, 0, 0, 1,
00199         1, 1, 1, 1,
00200         1, 1, 1, 1,
00201         1, 1, 1, 1,
00202         1, 1, 1, 1,
00203         1, 1, 1, 1,
00204         1, 1, 1, 1,
00205         1, 1, 1, 1,
00206         1, 1, 1, 1,
00207         1, 1, 1, 1,
00208         1, 1, 1, 1,
00209         1, 1, 1, 1,
00210         1, 1, 1, 1,
00211         1, 1, 1, 1,
00212         1, 1, 1, 1,
00213         1, 1, 1, 1,
00214         1, 1, 1, 2,
00215         2, 2, 2, 2,
00216         2, 2, 2, 2,
00217         2, 2, 2, 2,
00218         2, 2, 2, 2,
00219         2, 2, 2, 2,
00220         2, 2, 2, 2,
00221         2, 2, 2, 2,
00222         2, 2, 2, 2,
00223         2, 2, 2, 2,
00224         2, 2, 2, 2,
00225         2, 2, 2, 2,
00226         2, 2, 2, 2,
00227         2, 2, 2, 2,
00228         2, 2, 2, 2,
00229         2, 2, 2, 2,
00230         2, 2, 2, 3,
00231         3, 3, 3, 3,
00232         3, 3, 3, 3,
00233         3, 3, 3, 3,
00234         3, 3, 3, 3,
00235         3, 3, 3, 3,
00236         3, 3, 3, 3,
00237         3, 3, 3, 3,
00238         3, 3, 3, 3,
00239         3, 3, 3, 3,
00240         3, 3, 3, 3,
00241         3, 3, 3, 3,
00242         3, 3, 3, 3,
00243         3, 3, 3, 3,
00244         3, 3, 3, 3,
00245         3, 3, 3, 3,
00246         3, 3, 3, 4
00247 \};
00248 
00249 \textcolor{comment}{/*}
00250 \textcolor{comment}{ * Returns the number of 1-bits in x.}
00251 \textcolor{comment}{ */}
00252 \textcolor{keyword}{static} \textcolor{keyword}{inline} \textcolor{keywordtype}{int} \_\_builtin\_popcountAVX(NODETYPE x) \{
00253         \textcolor{keywordflow}{return} \_\_builtin\_popcountll(x.ui64[0]) + \_\_builtin\_popcountll(x.ui64[1]) + \_\_builtin\_popcountll(x.
      ui64[2]) + \_\_builtin\_popcountll(x.ui64[3]);
00254 \}
00255 
00256 \textcolor{comment}{/*}
00257 \textcolor{comment}{ * Returns one plus the index of the least significant 1-bit of x, or if x is zero, returns zero.}
00258 \textcolor{comment}{ */}
00259 \textcolor{keyword}{static} \textcolor{keyword}{inline} \textcolor{keywordtype}{int} \_\_builtin\_ffsAVX(NODETYPE x)\{
00260         \textcolor{keywordflow}{if} (x.ui64[0] != 0)
00261                 \textcolor{keywordflow}{return} \_\_builtin\_ffsll(x.ui64[0]);
00262         \textcolor{keywordflow}{if} (x.ui64[1] != 0)
00263                 \textcolor{keywordflow}{return} \_\_builtin\_ffsll(x.ui64[1]) + 64;
00264         \textcolor{keywordflow}{if} (x.ui64[2] != 0)
00265                 \textcolor{keywordflow}{return} \_\_builtin\_ffsll(x.ui64[2]) + 128;
00266         \textcolor{keywordflow}{if} (x.ui64[3] != 0)
00267                 \textcolor{keywordflow}{return} \_\_builtin\_ffsll(x.ui64[3]) + 192;
00268         \textcolor{keywordflow}{return} 0;
00269 \}
00270 
00271 
00272 \textcolor{comment}{/*}
00273 \textcolor{comment}{ * Returns one plus the index of the significant 1-bit of x next to i, or if x is zero, returns zero.}
00274 \textcolor{comment}{ */}
00275 \textcolor{keyword}{static} \textcolor{keyword}{inline} \textcolor{keywordtype}{int} \_\_builtin\_nextffsAVX(NODETYPE x, \textcolor{keywordtype}{int} i) \{
00276         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} masked;
00277 
00278         i++;
00279         \textcolor{keywordflow}{if} (i < 64)
00280         \{
00281                 masked = x.ui64[0] & \_\_mask[i];
00282                 \textcolor{keywordflow}{if} (masked != 0)
00283                         \textcolor{keywordflow}{return} \_\_builtin\_ffsll(masked);
00284                 i = 64;
00285         \}
00286         \textcolor{keywordflow}{if} (i < 128)
00287         \{
00288                 masked = x.ui64[1] & \_\_mask[i];
00289                 \textcolor{keywordflow}{if} (masked != 0)
00290                         \textcolor{keywordflow}{return} \_\_builtin\_ffsll(masked) + 64;
00291                 i = 128;
00292         \}
00293         \textcolor{keywordflow}{if} (i < 192)
00294         \{
00295                 masked = x.ui64[2] & \_\_mask[i];
00296                 \textcolor{keywordflow}{if}(masked !=0)
00297                         \textcolor{keywordflow}{return} \_\_builtin\_ffsll(masked) + 128;
00298                 i = 192;
00299         \}
00300         masked = x.ui64[3] & \_\_mask[i];
00301         \textcolor{keywordflow}{if} (masked == 0)
00302                 \textcolor{keywordflow}{return} 0;
00303         \textcolor{keywordflow}{return} \_\_builtin\_ffsll(masked) + 192;
00304 \}
00305 
00306 \textcolor{keyword}{static} \textcolor{keyword}{inline} \textcolor{keywordtype}{int} \_\_builtin\_prevclzAVX(NODETYPE x, \textcolor{keywordtype}{int} i) \{
00307         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} masked;
00308 
00309         \textcolor{keywordflow}{if} (i > 192)
00310         \{
00311                 masked = x.ui64[3] & ~\_\_mask[i];
00312                 \textcolor{keywordflow}{if} (masked != 0)
00313                         \textcolor{keywordflow}{return} \_\_builtin\_clzll(masked);
00314                 i = 192;
00315         \}
00316         \textcolor{keywordflow}{if} (i > 128)
00317         \{
00318                 \textcolor{keywordflow}{if} (i < 192)
00319                         masked = x.ui64[2] & ~\_\_mask[i];
00320                 \textcolor{keywordflow}{else}
00321                         masked = x.ui64[2];
00322                 \textcolor{keywordflow}{if} (masked != 0)
00323                         \textcolor{keywordflow}{return} \_\_builtin\_clzll(masked) + 64;
00324                 i = 128;
00325         \}
00326         \textcolor{keywordflow}{if} (i > 64)
00327         \{
00328                 \textcolor{keywordflow}{if} (i < 128)
00329                         masked = x.ui64[1] & ~\_\_mask[i];
00330                 \textcolor{keywordflow}{else}
00331                         masked = x.ui64[1];
00332                 \textcolor{keywordflow}{if} (masked != 0)
00333                         \textcolor{keywordflow}{return} \_\_builtin\_clzll(masked) + 128;
00334                 i = 64;
00335         \}
00336         \textcolor{keywordflow}{if} (i < 64)
00337                 masked = x.ui64[0] & ~\_\_mask[i];
00338         \textcolor{keywordflow}{else}
00339                 masked = x.ui64[0];
00340         \textcolor{keywordflow}{if} (masked == 0)
00341                 \textcolor{keywordflow}{return} BSIZE;
00342         \textcolor{keywordflow}{return} \_\_builtin\_clzll(masked) + 192;
00343 \}
00344 
00345 \textcolor{keyword}{static} \textcolor{keyword}{inline} \textcolor{keywordtype}{int} \_\_builtin\_clzAVX(NODETYPE x) \{
00346         \textcolor{keywordflow}{if} (x.ui64[3] != 0)
00347                 \textcolor{keywordflow}{return} \_\_builtin\_clzll(x.ui64[3]);
00348         \textcolor{keywordflow}{if} (x.ui64[2] != 0)
00349                 \textcolor{keywordflow}{return} \_\_builtin\_clzll(x.ui64[2]) + 64;
00350         \textcolor{keywordflow}{if} (x.ui64[1] != 0)
00351                 \textcolor{keywordflow}{return} \_\_builtin\_clzll(x.ui64[1]) + 128;
00352         \textcolor{keywordflow}{if} (x.ui64[0] != 0)
00353                 \textcolor{keywordflow}{return} \_\_builtin\_clzll(x.ui64[0]) + 192;
00354         \textcolor{keywordflow}{return} BSIZE;
00355 \}
00356 
00357 
00358 \textcolor{preprocessor}{#define NODECOUNTER(i) \_\_builtin\_popcountAVX(i)}
00359 \textcolor{preprocessor}{#define NODELEAST(w) (\_\_builtin\_ffsAVX(w)-1)}
00360 \textcolor{preprocessor}{#define NODENEXTLEAST(w, i) (\_\_builtin\_nextffsAVX((w), (i))-1)}
00361 \textcolor{preprocessor}{#define NODEMOST(i) (BSIZE-\_\_builtin\_clzAVX(i)-1)}
00362 \textcolor{preprocessor}{#define NODEPREVMOST(w, i) (BSIZE-\_\_builtin\_prevclzAVX((w), (i))-1)}
00363 \textcolor{preprocessor}{#define NODEISEMPTY(w) ((w).ui64[0] == 0 && (w).ui64[1] == 0 && (w).ui64[2] == 0  && (w).ui64[3] == 0 )}
00364 \textcolor{preprocessor}{#define NODEISNOTEMPTY(w) ((w).ui64[0] != 0 || (w).ui64[1] != 0 || (w).ui64[2] != 0 || (w).ui64[3] != 0)}
00365 \textcolor{preprocessor}{#define ISINNODE(w, i) ((w) & \_\_oneshifted[i])                                                  }
00366 \textcolor{preprocessor}{}
00367 \textcolor{preprocessor}{#elif \_ARCH128\_}
00368 \textcolor{preprocessor}{#include <smmintrin.h>} \textcolor{comment}{// SSE4}
00369 
00370 \textcolor{keyword}{typedef} \textcolor{keyword}{union }\{
00371     \_\_m128i mi;
00372     \_\_m128 m;
00373     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} ui64[2];
00374 \} NODETYPE; 
00375 
00376 \textcolor{keyword}{static} \textcolor{keyword}{const} NODETYPE \_\_zero = \{ .ui64 = \{ 0, 0 \} \};
00377 
00378 \textcolor{preprocessor}{#define BSIZE 128}
00379 \textcolor{preprocessor}{#define WSIZE 16}
00380 \textcolor{preprocessor}{#define LOGB 7LL}
00381 \textcolor{preprocessor}{#define LOGW 4}
00382 \textcolor{preprocessor}{#define LOGBW 11}
00383 
00384 \textcolor{preprocessor}{#define ONE 1LL}
00385 \textcolor{preprocessor}{#define NODEMAX 0xFFFFFFFFFFFFFFFF}
00386 \textcolor{preprocessor}{#define MASKB 0x7FLL}
00387 \textcolor{comment}{//#define MASKB 0xFFFFFFFFFFFFFFC0}
00388 
00389 \textcolor{preprocessor}{#define MASKSZ (BSIZE+1)}
00390 \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \_\_mask[MASKSZ] = \{
00391         0xFFFFFFFFFFFFFFFF,
00392         0xFFFFFFFFFFFFFFFE, 0xFFFFFFFFFFFFFFFC, 0xFFFFFFFFFFFFFFF8, 0xFFFFFFFFFFFFFFF0,
00393         0xFFFFFFFFFFFFFFE0, 0xFFFFFFFFFFFFFFC0, 0xFFFFFFFFFFFFFF80, 0xFFFFFFFFFFFFFF00,
00394         0xFFFFFFFFFFFFFE00, 0xFFFFFFFFFFFFFC00, 0xFFFFFFFFFFFFF800, 0xFFFFFFFFFFFFF000,
00395         0xFFFFFFFFFFFFE000, 0xFFFFFFFFFFFFC000, 0xFFFFFFFFFFFF8000, 0xFFFFFFFFFFFF0000,
00396         0xFFFFFFFFFFFE0000, 0xFFFFFFFFFFFC0000, 0xFFFFFFFFFFF80000, 0xFFFFFFFFFFF00000,
00397         0xFFFFFFFFFFE00000, 0xFFFFFFFFFFC00000, 0xFFFFFFFFFF800000, 0xFFFFFFFFFF000000,
00398         0xFFFFFFFFFE000000, 0xFFFFFFFFFC000000, 0xFFFFFFFFF8000000, 0xFFFFFFFFF0000000,
00399         0xFFFFFFFFE0000000, 0xFFFFFFFFC0000000, 0xFFFFFFFF80000000, 0xFFFFFFFF00000000,
00400         0xFFFFFFFE00000000, 0xFFFFFFFC00000000, 0xFFFFFFF800000000, 0xFFFFFFF000000000,
00401         0xFFFFFFE000000000, 0xFFFFFFC000000000, 0xFFFFFF8000000000, 0xFFFFFF0000000000,
00402         0xFFFFFE0000000000, 0xFFFFFC0000000000, 0xFFFFF80000000000, 0xFFFFF00000000000,
00403         0xFFFFE00000000000, 0xFFFFC00000000000, 0xFFFF800000000000, 0xFFFF000000000000,
00404         0xFFFE000000000000, 0xFFFC000000000000, 0xFFF8000000000000, 0xFFF0000000000000,
00405         0xFFE0000000000000, 0xFFC0000000000000, 0xFF80000000000000, 0xFF00000000000000,
00406         0xFE00000000000000, 0xFC00000000000000, 0xF800000000000000, 0xF000000000000000,
00407         0xE000000000000000, 0xC000000000000000, 0x8000000000000000, 0xFFFFFFFFFFFFFFFF,
00408         0xFFFFFFFFFFFFFFFE, 0xFFFFFFFFFFFFFFFC, 0xFFFFFFFFFFFFFFF8, 0xFFFFFFFFFFFFFFF0,
00409         0xFFFFFFFFFFFFFFE0, 0xFFFFFFFFFFFFFFC0, 0xFFFFFFFFFFFFFF80, 0xFFFFFFFFFFFFFF00,
00410         0xFFFFFFFFFFFFFE00, 0xFFFFFFFFFFFFFC00, 0xFFFFFFFFFFFFF800, 0xFFFFFFFFFFFFF000,
00411         0xFFFFFFFFFFFFE000, 0xFFFFFFFFFFFFC000, 0xFFFFFFFFFFFF8000, 0xFFFFFFFFFFFF0000,
00412         0xFFFFFFFFFFFE0000, 0xFFFFFFFFFFFC0000, 0xFFFFFFFFFFF80000, 0xFFFFFFFFFFF00000,
00413         0xFFFFFFFFFFE00000, 0xFFFFFFFFFFC00000, 0xFFFFFFFFFF800000, 0xFFFFFFFFFF000000,
00414         0xFFFFFFFFFE000000, 0xFFFFFFFFFC000000, 0xFFFFFFFFF8000000, 0xFFFFFFFFF0000000,
00415         0xFFFFFFFFE0000000, 0xFFFFFFFFC0000000, 0xFFFFFFFF80000000, 0xFFFFFFFF00000000,
00416         0xFFFFFFFE00000000, 0xFFFFFFFC00000000, 0xFFFFFFF800000000, 0xFFFFFFF000000000,
00417         0xFFFFFFE000000000, 0xFFFFFFC000000000, 0xFFFFFF8000000000, 0xFFFFFF0000000000,
00418         0xFFFFFE0000000000, 0xFFFFFC0000000000, 0xFFFFF80000000000, 0xFFFFF00000000000,
00419         0xFFFFE00000000000, 0xFFFFC00000000000, 0xFFFF800000000000, 0xFFFF000000000000,
00420         0xFFFE000000000000, 0xFFFC000000000000, 0xFFF8000000000000, 0xFFF0000000000000,
00421         0xFFE0000000000000, 0xFFC0000000000000, 0xFF80000000000000, 0xFF00000000000000,
00422         0xFE00000000000000, 0xFC00000000000000, 0xF800000000000000, 0xF000000000000000,
00423         0xE000000000000000, 0xC000000000000000, 0x8000000000000000, 0x0000000000000000
00424 \};
00425 
00426 \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \_\_oneshifted[MASKSZ] = \{
00427         0x0000000000000001,
00428         0x0000000000000002, 0x0000000000000004, 0x0000000000000008, 0x0000000000000010,
00429         0x0000000000000020, 0x0000000000000040, 0x0000000000000080, 0x0000000000000100,
00430         0x0000000000000200, 0x0000000000000400, 0x0000000000000800, 0x0000000000001000,
00431         0x0000000000002000, 0x0000000000004000, 0x0000000000008000, 0x0000000000010000,
00432         0x0000000000020000, 0x0000000000040000, 0x0000000000080000, 0x0000000000100000,
00433         0x0000000000200000, 0x0000000000400000, 0x0000000000800000, 0x0000000001000000,
00434         0x0000000002000000, 0x0000000004000000, 0x0000000008000000, 0x0000000010000000,
00435         0x0000000020000000, 0x0000000040000000, 0x0000000080000000, 0x0000000100000000,
00436         0x0000000200000000, 0x0000000400000000, 0x0000000800000000, 0x0000001000000000,
00437         0x0000002000000000, 0x0000004000000000, 0x0000008000000000, 0x0000010000000000,
00438         0x0000020000000000, 0x0000040000000000, 0x0000080000000000, 0x0000100000000000,
00439         0x0000200000000000, 0x0000400000000000, 0x0000800000000000, 0x0001000000000000,
00440         0x0002000000000000, 0x0004000000000000, 0x0008000000000000, 0x0010000000000000,
00441         0x0020000000000000, 0x0040000000000000, 0x0080000000000000, 0x0100000000000000,
00442         0x0200000000000000, 0x0400000000000000, 0x0800000000000000, 0x1000000000000000,
00443         0x2000000000000000, 0x4000000000000000, 0x8000000000000000, 0x0000000000000001,
00444         0x0000000000000002, 0x0000000000000004, 0x0000000000000008, 0x0000000000000010,
00445         0x0000000000000020, 0x0000000000000040, 0x0000000000000080, 0x0000000000000100,
00446         0x0000000000000200, 0x0000000000000400, 0x0000000000000800, 0x0000000000001000,
00447         0x0000000000002000, 0x0000000000004000, 0x0000000000008000, 0x0000000000010000,
00448         0x0000000000020000, 0x0000000000040000, 0x0000000000080000, 0x0000000000100000,
00449         0x0000000000200000, 0x0000000000400000, 0x0000000000800000, 0x0000000001000000,
00450         0x0000000002000000, 0x0000000004000000, 0x0000000008000000, 0x0000000010000000,
00451         0x0000000020000000, 0x0000000040000000, 0x0000000080000000, 0x0000000100000000,
00452         0x0000000200000000, 0x0000000400000000, 0x0000000800000000, 0x0000001000000000,
00453         0x0000002000000000, 0x0000004000000000, 0x0000008000000000, 0x0000010000000000,
00454         0x0000020000000000, 0x0000040000000000, 0x0000080000000000, 0x0000100000000000,
00455         0x0000200000000000, 0x0000400000000000, 0x0000800000000000, 0x0001000000000000,
00456         0x0002000000000000, 0x0004000000000000, 0x0008000000000000, 0x0010000000000000,
00457         0x0020000000000000, 0x0040000000000000, 0x0080000000000000, 0x0100000000000000,
00458         0x0200000000000000, 0x0400000000000000, 0x0800000000000000, 0x1000000000000000,
00459         0x2000000000000000, 0x4000000000000000, 0x8000000000000000, 0x0000000000000000
00460 \};
00461 
00462 \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{char} \_\_index[MASKSZ] = \{
00463         0,
00464         0, 0, 0, 0,
00465         0, 0, 0, 0,
00466         0, 0, 0, 0,
00467         0, 0, 0, 0,
00468         0, 0, 0, 0,
00469         0, 0, 0, 0,
00470         0, 0, 0, 0,
00471         0, 0, 0, 0,
00472         0, 0, 0, 0,
00473         0, 0, 0, 0,
00474         0, 0, 0, 0,
00475         0, 0, 0, 0,
00476         0, 0, 0, 0,
00477         0, 0, 0, 0,
00478         0, 0, 0, 0,
00479         0, 0, 0, 1,
00480         1, 1, 1, 1,
00481         1, 1, 1, 1,
00482         1, 1, 1, 1,
00483         1, 1, 1, 1,
00484         1, 1, 1, 1,
00485         1, 1, 1, 1,
00486         1, 1, 1, 1,
00487         1, 1, 1, 1,
00488         1, 1, 1, 1,
00489         1, 1, 1, 1,
00490         1, 1, 1, 1,
00491         1, 1, 1, 1,
00492         1, 1, 1, 1,
00493         1, 1, 1, 1,
00494         1, 1, 1, 1,
00495         1, 1, 1, 2
00496 \};
00497 
00498 \textcolor{comment}{/*}
00499 \textcolor{comment}{ * Returns the number of 1-bits in x.}
00500 \textcolor{comment}{ */}
00501 \textcolor{keyword}{static} \textcolor{keyword}{inline} \textcolor{keywordtype}{int} \_\_builtin\_popcountsse(NODETYPE x) \{
00502         \textcolor{keywordflow}{return} \_\_builtin\_popcountll(x.ui64[0]) + \_\_builtin\_popcountll(x.ui64[1]);
00503 \}
00504 
00505 \textcolor{comment}{/*}
00506 \textcolor{comment}{ * Returns one plus the index of the least significant 1-bit of x, or if x is zero, returns zero.}
00507 \textcolor{comment}{ */}
00508 \textcolor{keyword}{static} \textcolor{keyword}{inline} \textcolor{keywordtype}{int} \_\_builtin\_ffssse(NODETYPE x) \{
00509         \textcolor{keywordflow}{if} (x.ui64[0] != 0)
00510                 \textcolor{keywordflow}{return} \_\_builtin\_ffsll(x.ui64[0]);
00511         \textcolor{keywordflow}{if} (x.ui64[1] != 0)
00512                 \textcolor{keywordflow}{return} \_\_builtin\_ffsll(x.ui64[1]) + 64;
00513         \textcolor{keywordflow}{return} 0;
00514 \}
00515 
00516 \textcolor{comment}{/*}
00517 \textcolor{comment}{ * Returns one plus the index of the significant 1-bit of x next to i, or if x is zero, returns zero.}
00518 \textcolor{comment}{ */}
00519 \textcolor{keyword}{static} \textcolor{keyword}{inline} \textcolor{keywordtype}{int} \_\_builtin\_nextffssse(NODETYPE x, \textcolor{keywordtype}{int} i) \{
00520         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} masked;
00521         i++;
00522         \textcolor{keywordflow}{if} (i < 64)
00523         \{
00524                 masked = x.ui64[0] & \_\_mask[i];
00525                 \textcolor{keywordflow}{if} (masked != 0)
00526                         \textcolor{keywordflow}{return} \_\_builtin\_ffsll(masked);
00527                 i = 64;
00528         \}
00529         masked = x.ui64[1] & \_\_mask[i];
00530         \textcolor{keywordflow}{if} (masked == 0)
00531                 \textcolor{keywordflow}{return} 0;
00532         \textcolor{keywordflow}{return} \_\_builtin\_ffsll(masked) + 64;
00533 \}
00534 
00535 \textcolor{comment}{/*}
00536 \textcolor{comment}{ * Returns the number of leading 0-bits in x, starting at the most significant bit position. If x is 0, the
       result is BSIZE.}
00537 \textcolor{comment}{ */}
00538 \textcolor{keyword}{static} \textcolor{keyword}{inline} \textcolor{keywordtype}{int} \_\_builtin\_clzsse(NODETYPE x) \{
00539         \textcolor{keywordflow}{if} (x.ui64[1] != 0)
00540                 \textcolor{keywordflow}{return} \_\_builtin\_clzll(x.ui64[1]);
00541         \textcolor{keywordflow}{if} (x.ui64[0] != 0)
00542                 \textcolor{keywordflow}{return} \_\_builtin\_clzll(x.ui64[0]) + 64;
00543         \textcolor{keywordflow}{return} BSIZE;
00544 \}
00545 
00546 \textcolor{comment}{/*}
00547 \textcolor{comment}{ * Returns the number of leading 0-bits in x, starting at ith-bit position. If x is 0, the result is BSIZE.}
00548 \textcolor{comment}{ */}
00549 \textcolor{keyword}{static} \textcolor{keyword}{inline} \textcolor{keywordtype}{int} \_\_builtin\_prevclzsse(NODETYPE x, \textcolor{keywordtype}{int} i) \{
00550         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} masked;
00551         \textcolor{keywordflow}{if} (i > 64)
00552         \{
00553                 masked = x.ui64[1] & ~\_\_mask[i];
00554                 \textcolor{keywordflow}{if} (masked != 0)
00555                         \textcolor{keywordflow}{return} \_\_builtin\_clzll(masked);
00556                 i = 64;
00557         \}
00558         \textcolor{keywordflow}{if} (i < 64)
00559                 masked = x.ui64[0] & ~\_\_mask[i];
00560         \textcolor{keywordflow}{else}
00561                 masked = x.ui64[0];
00562         \textcolor{keywordflow}{if} (masked == 0)
00563                 \textcolor{keywordflow}{return} BSIZE;
00564         \textcolor{keywordflow}{return} \_\_builtin\_clzll(masked) + 64;
00565 \}
00566 
00567 \textcolor{preprocessor}{#define NODECOUNTER(i) \_\_builtin\_popcountsse(i)}
00568 \textcolor{preprocessor}{#define NODELEAST(w) (\_\_builtin\_ffssse(w)-1)}
00569 \textcolor{preprocessor}{#define NODENEXTLEAST(w, i) (\_\_builtin\_nextffssse((w), (i))-1)}
00570 \textcolor{preprocessor}{#define NODEMOST(i) (BSIZE-\_\_builtin\_clzsse(i)-1)}
00571 \textcolor{preprocessor}{#define NODEPREVMOST(w, i) (BSIZE-\_\_builtin\_prevclzsse((w), (i))-1)}
00572 \textcolor{preprocessor}{#define NODEISEMPTY(w) ((w).ui64[0] == 0 && (w).ui64[1] == 0)}
00573 \textcolor{preprocessor}{#define NODEISNOTEMPTY(w) ((w).ui64[0] != 0 || (w).ui64[1] != 0)}
00574 \textcolor{preprocessor}{#define ISINNODE(w, i) ((w) & \_\_oneshifted[i])                                                  }
00575 \textcolor{preprocessor}{}
00576 \textcolor{preprocessor}{#elif \_ARCH32\_  // see comments at #ifdef \_ARCH8\_}
00577 \textcolor{keyword}{typedef} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} NODETYPE; 
00578 \textcolor{preprocessor}{#define BSIZE 32                                        }
00579 \textcolor{preprocessor}{#define WSIZE 4                                         }
00580 \textcolor{preprocessor}{#define LOGB 5L                                         }
00581 \textcolor{preprocessor}{#define LOGW 2L                                         }
00582 \textcolor{preprocessor}{#define LOGBW 7L                                        }
00583 \textcolor{preprocessor}{#define ONE 1L                                          }
00584 \textcolor{preprocessor}{#define NODEMAX 0xFFFFFFFF                      }
00585 \textcolor{preprocessor}{#define MASKB 0x1FL                                     }
00586 \textcolor{preprocessor}{//#define MASKB 0xFFFFFFE0}
00587 
00588 \textcolor{preprocessor}{#define MASKSZ (BSIZE+1)                        }
00589 \textcolor{preprocessor}{static const NODETYPE \_\_mask[MASKSZ] = \{}
00590         0xFFFFFFFF,
00591         0xFFFFFFFE, 0xFFFFFFFC, 0xFFFFFFF8, 0xFFFFFFF0,
00592         0xFFFFFFE0, 0xFFFFFFC0, 0xFFFFFF80, 0xFFFFFF00,
00593         0xFFFFFE00, 0xFFFFFC00, 0xFFFFF800, 0xFFFFF000,
00594         0xFFFFE000, 0xFFFFC000, 0xFFFF8000, 0xFFFF0000,
00595         0xFFFE0000, 0xFFFC0000, 0xFFF80000, 0xFFF00000,
00596         0xFFE00000, 0xFFC00000, 0xFF800000, 0xFF000000,
00597         0xFE000000, 0xFC000000, 0xF8000000, 0xF0000000,
00598         0xE0000000, 0xC0000000, 0x80000000, 0x00000000
00599 \};
00600 
00601 \textcolor{keyword}{static} \textcolor{keyword}{const} NODETYPE \_\_oneshifted[MASKSZ] = \{
00602         0x00000001,
00603         0x00000002, 0x00000004, 0x00000008, 0x00000010,
00604         0x00000020, 0x00000040, 0x00000080, 0x00000100,
00605         0x00000200, 0x00000400, 0x00000800, 0x00001000,
00606         0x00002000, 0x00004000, 0x00008000, 0x00010000,
00607         0x00020000, 0x00040000, 0x00080000, 0x00100000,
00608         0x00200000, 0x00400000, 0x00800000, 0x01000000,
00609         0x02000000, 0x04000000, 0x08000000, 0x10000000,
00610         0x20000000, 0x40000000, 0x80000000, 0x00000000
00611 \};
00612 
00613 \textcolor{keyword}{static} \textcolor{keyword}{inline} \textcolor{keywordtype}{int} nodeMost(NODETYPE i) \{
00614         \textcolor{keywordflow}{return} (i) == 0 ? -1 : BSIZE-\_\_builtin\_clzl(i)-1;
00615 \}
00616 
00617 \textcolor{preprocessor}{#define NODECOUNTER(i) \_\_builtin\_popcountl(i)}
00618 \textcolor{preprocessor}{#define NODELEAST(w) (\_\_builtin\_ffsl(w)-1)}
00619 \textcolor{preprocessor}{#define NODENEXTLEAST(w, i) (NODELEAST((w) & \_\_mask[i + 1]))}
00620 \textcolor{preprocessor}{#define NODEMOST(i) (nodeMost(i))}
00621 \textcolor{preprocessor}{#define NODEPREVMOST(w, i) (NODEMOST((w) & ~\_\_mask[i]))}
00622 \textcolor{preprocessor}{#define NODEISEMPTY(w) (w == 0)}
00623 \textcolor{preprocessor}{#define NODEISNOTEMPTY(w) (w != 0)}
00624 \textcolor{preprocessor}{#define ISINNODE(w, i) ((w) & (ONE << (i)))                                                     }
00625 \textcolor{preprocessor}{}
00626 \textcolor{preprocessor}{#elif \_ARCH64\_}
00627 
00628 \textcolor{keyword}{typedef} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} NODETYPE; 
00629 \textcolor{preprocessor}{#define BSIZE 64}
00630 \textcolor{preprocessor}{#define WSIZE 8}
00631 \textcolor{preprocessor}{#define LOGB 6LL}
00632 \textcolor{preprocessor}{#define LOGW 3}
00633 \textcolor{preprocessor}{#define LOGBW 9}
00634 
00635 \textcolor{preprocessor}{#define ONE 1LL}
00636 \textcolor{preprocessor}{#define NODEMAX 0xFFFFFFFFFFFFFFFF}
00637 \textcolor{preprocessor}{#define MASKB 0x3FLL}
00638 \textcolor{comment}{//#define MASKB 0xFFFFFFFFFFFFFFC0}
00639 
00640 \textcolor{preprocessor}{#define MASKSZ (BSIZE+1)}
00641 \textcolor{keyword}{static} \textcolor{keyword}{const} NODETYPE \_\_mask[MASKSZ] = \{
00642         0xFFFFFFFFFFFFFFFF,
00643         0xFFFFFFFFFFFFFFFE, 0xFFFFFFFFFFFFFFFC, 0xFFFFFFFFFFFFFFF8, 0xFFFFFFFFFFFFFFF0,
00644         0xFFFFFFFFFFFFFFE0, 0xFFFFFFFFFFFFFFC0, 0xFFFFFFFFFFFFFF80, 0xFFFFFFFFFFFFFF00,
00645         0xFFFFFFFFFFFFFE00, 0xFFFFFFFFFFFFFC00, 0xFFFFFFFFFFFFF800, 0xFFFFFFFFFFFFF000,
00646         0xFFFFFFFFFFFFE000, 0xFFFFFFFFFFFFC000, 0xFFFFFFFFFFFF8000, 0xFFFFFFFFFFFF0000,
00647         0xFFFFFFFFFFFE0000, 0xFFFFFFFFFFFC0000, 0xFFFFFFFFFFF80000, 0xFFFFFFFFFFF00000,
00648         0xFFFFFFFFFFE00000, 0xFFFFFFFFFFC00000, 0xFFFFFFFFFF800000, 0xFFFFFFFFFF000000,
00649         0xFFFFFFFFFE000000, 0xFFFFFFFFFC000000, 0xFFFFFFFFF8000000, 0xFFFFFFFFF0000000,
00650         0xFFFFFFFFE0000000, 0xFFFFFFFFC0000000, 0xFFFFFFFF80000000, 0xFFFFFFFF00000000,
00651         0xFFFFFFFE00000000, 0xFFFFFFFC00000000, 0xFFFFFFF800000000, 0xFFFFFFF000000000,
00652         0xFFFFFFE000000000, 0xFFFFFFC000000000, 0xFFFFFF8000000000, 0xFFFFFF0000000000,
00653         0xFFFFFE0000000000, 0xFFFFFC0000000000, 0xFFFFF80000000000, 0xFFFFF00000000000,
00654         0xFFFFE00000000000, 0xFFFFC00000000000, 0xFFFF800000000000, 0xFFFF000000000000,
00655         0xFFFE000000000000, 0xFFFC000000000000, 0xFFF8000000000000, 0xFFF0000000000000,
00656         0xFFE0000000000000, 0xFFC0000000000000, 0xFF80000000000000, 0xFF00000000000000,
00657         0xFE00000000000000, 0xFC00000000000000, 0xF800000000000000, 0xF000000000000000,
00658         0xE000000000000000, 0xC000000000000000, 0x8000000000000000, 0x0000000000000000
00659 \};
00660 
00661 \textcolor{keyword}{static} \textcolor{keyword}{const} NODETYPE \_\_oneshifted[MASKSZ] = \{
00662         0x0000000000000001,
00663         0x0000000000000002, 0x0000000000000004, 0x0000000000000008, 0x0000000000000010,
00664         0x0000000000000020, 0x0000000000000040, 0x0000000000000080, 0x0000000000000100,
00665         0x0000000000000200, 0x0000000000000400, 0x0000000000000800, 0x0000000000001000,
00666         0x0000000000002000, 0x0000000000004000, 0x0000000000008000, 0x0000000000010000,
00667         0x0000000000020000, 0x0000000000040000, 0x0000000000080000, 0x0000000000100000,
00668         0x0000000000200000, 0x0000000000400000, 0x0000000000800000, 0x0000000001000000,
00669         0x0000000002000000, 0x0000000004000000, 0x0000000008000000, 0x0000000010000000,
00670         0x0000000020000000, 0x0000000040000000, 0x0000000080000000, 0x0000000100000000,
00671         0x0000000200000000, 0x0000000400000000, 0x0000000800000000, 0x0000001000000000,
00672         0x0000002000000000, 0x0000004000000000, 0x0000008000000000, 0x0000010000000000,
00673         0x0000020000000000, 0x0000040000000000, 0x0000080000000000, 0x0000100000000000,
00674         0x0000200000000000, 0x0000400000000000, 0x0000800000000000, 0x0001000000000000,
00675         0x0002000000000000, 0x0004000000000000, 0x0008000000000000, 0x0010000000000000,
00676         0x0020000000000000, 0x0040000000000000, 0x0080000000000000, 0x0100000000000000,
00677         0x0200000000000000, 0x0400000000000000, 0x0800000000000000, 0x1000000000000000,
00678         0x2000000000000000, 0x4000000000000000, 0x8000000000000000, 0x0000000000000000
00679 \};
00680 
00681 \textcolor{keyword}{static} \textcolor{keyword}{inline} \textcolor{keywordtype}{int} nodeMost(NODETYPE i) \{
00682         \textcolor{keywordflow}{return} (i) == 0 ? -1 : BSIZE-\_\_builtin\_clzll(i)-1;
00683 \}
00684 
00685 \textcolor{preprocessor}{#define NODECOUNTER(i) \_\_builtin\_popcountll(i)}
00686 \textcolor{preprocessor}{#define NODELEAST(w) (\_\_builtin\_ffsll(w)-1)}
00687 \textcolor{preprocessor}{#define NODENEXTLEAST(w, i) (NODELEAST((w) & \_\_mask[i + 1]))}
00688 \textcolor{preprocessor}{#define NODEMOST(i) (nodeMost(i))}
00689 \textcolor{preprocessor}{#define NODEPREVMOST(w, i) (NODEMOST((w) & ~\_\_mask[i]))}
00690 \textcolor{preprocessor}{#define NODEISEMPTY(w) (w == 0)}
00691 \textcolor{preprocessor}{#define NODEISNOTEMPTY(w) (w != 0)}
00692 \textcolor{preprocessor}{#define ISINNODE(w, i) ((w) & (ONE << (i)))                                                     }
00693 \textcolor{preprocessor}{}
00694 \textcolor{preprocessor}{#else}
00695 
00699 \textcolor{keyword}{typedef} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} NODETYPE;                         
00700 \textcolor{preprocessor}{#define BSIZE 8                                                         }
00701 \textcolor{preprocessor}{#define WSIZE 1                                                         }
00702 \textcolor{preprocessor}{#define LOGB 3                                                          }
00703 \textcolor{preprocessor}{#define LOGW 0                                                          }
00704 \textcolor{preprocessor}{#define LOGBW 3                                                         }
00705 \textcolor{preprocessor}{#define ONE 1                                                           }
00706 \textcolor{preprocessor}{#define NODEMAX 0xFF                                            }
00707 \textcolor{preprocessor}{#define MASKB 0x07                                                      }
00708 \textcolor{preprocessor}{//#define MASKB 0xFFFFFFE0}
00709 
00710 \textcolor{preprocessor}{#define MASKSZ (BSIZE+1)                                        }
00711 \textcolor{preprocessor}{static const NODETYPE \_\_mask[MASKSZ] = \{ }
00712 \textcolor{preprocessor}{                0xFF, 0xFE, 0xFC, 0xF8, 0xF0, 0xE0, 0xC0, 0x80, 0x00 \};}
00713 
00714 \textcolor{keyword}{static} \textcolor{keyword}{inline} \textcolor{keywordtype}{int} nodeMost(NODETYPE i) \{
00715         \textcolor{keywordflow}{return} (i) == 0 ? -1 : BSIZE-\_\_builtin\_clz(i)-1;
00716 \}
00717 
00718 \textcolor{preprocessor}{#define NODECOUNTER(w) \_\_builtin\_popcount(w)                                            }
00719 \textcolor{preprocessor}{#define NODELEAST(w) (\_\_builtin\_ffs(w)-1)                                                       }
00720 \textcolor{preprocessor}{#define NODENEXTLEAST(w, i) (NODELEAST((w) & \_\_mask[i + 1]))            }
00721 \textcolor{preprocessor}{#define NODEMOST(i) (nodeMost(i))                                                                       }
00722 \textcolor{preprocessor}{#define NODEPREVMOST(w, i) (NODEMOST((w) & ~\_\_mask[i]))                         }
00723 \textcolor{preprocessor}{#define NODEISEMPTY(w) (w == 0)}
00724 \textcolor{preprocessor}{#define NODEISNOTEMPTY(w) (w != 0)}
00725 \textcolor{preprocessor}{#define ISINNODE(w, i) ((w) & (ONE << (i)))                                                     }
00726 \textcolor{preprocessor}{#endif}
00727 
00728 \textcolor{preprocessor}{#define NELEM(i) ((i) << LOGB)                                                                          }
00729 \textcolor{preprocessor}{#define NODEIDX(i) ((i) >> LOGB)                                                                        }
00730 \textcolor{preprocessor}{#define IDXINNODE(i) ((i) & MASKB)                                                                      }
00731 \textcolor{preprocessor}{#define RETAINLEAST(w, i) ((w) & (NODEMAX >> (BSIZE-(i))))                      }
00732 \textcolor{preprocessor}{}
00733 
00745 \textcolor{keyword}{typedef} \textcolor{keyword}{struct }\{
00746         \textcolor{keyword}{const} \textcolor{keywordtype}{int} n;
00747         \textcolor{keyword}{const} \textcolor{keywordtype}{int} size;
00748         \textcolor{keyword}{const} \textcolor{keywordtype}{int} step;                 \textcolor{comment}{// in words}
00749         \textcolor{keyword}{const} \textcolor{keywordtype}{int} nRnodes;
00750         NODETYPE * minRNode;    \textcolor{comment}{//<! a lower bound for the node index of the smallest element in the set}
00751         NODETYPE * maxRNode;    \textcolor{comment}{//<! an upper bound for the node index of the greatest element in the set}
00752         \textcolor{keyword}{const} \textcolor{keywordtype}{char} * ptr;               
00753         NODETYPE * R;                   
00754 \} BitMap;
00755 
00760 \textcolor{keyword}{typedef} \textcolor{keyword}{struct }\{
00761         \textcolor{keywordtype}{int} ind;                        
00762         \textcolor{keywordtype}{int} nelem;                      
00763         \textcolor{keywordtype}{int} cur;                        
00764         NODETYPE * beg1;        
00765         NODETYPE * end1;        
00766         NODETYPE * buf1;        
00767 \} Node;
00768 
00769 \textcolor{keyword}{static} \textcolor{keywordtype}{void} printNode(Node * node);
00770 \textcolor{keyword}{static} \textcolor{keywordtype}{void} printSetNodes(BitMap \textcolor{keyword}{const} * s);
00771 
00772 \textcolor{keyword}{static} \textcolor{keyword}{inline} \textcolor{keywordtype}{int} inline\_ceillog2(\textcolor{keywordtype}{int} n) \{
00773         \textcolor{keywordtype}{int} c = 0;
00774         \textcolor{keywordtype}{int} l = 0;
00775         \textcolor{keywordflow}{while} (n > 1) \{
00776                 c |= (n & 1);
00777                 n >>= 1;
00778                 l++;
00779         \}
00780         l += c;
00781         \textcolor{keywordflow}{return} l;
00782 \}
00783 
00784 \textcolor{keyword}{static} \textcolor{keyword}{inline} BitMap *newBitMapVector(\textcolor{keywordtype}{size\_t} size, \textcolor{keywordtype}{size\_t} n) \{
00785         \textcolor{keywordtype}{int} tamR = NODEIDX(n-1) + 1;
00786         \textcolor{keywordtype}{int} step = inline\_ceillog2(tamR);
00787         \textcolor{keywordtype}{int} tamRS = 1 << step;
00788         \textcolor{keywordtype}{int} tam = (tamRS<<LOGW);
00789 
00790         BitMap * ret = (BitMap *) malloc(WSIZE+WSIZE+\textcolor{keyword}{sizeof}(BitMap)+tam*size);
00791         \textcolor{keywordflow}{if} (ret==NULL)
00792                 \textcolor{keywordflow}{return}(NULL);
00793 
00794         BitMap aux = \{ n, size, step, tamR, NULL, NULL, (\textcolor{keywordtype}{char} *) ret, NULL \};
00795         ret =  (BitMap *) (((\textcolor{keywordtype}{char} *) ret) + (WSIZE - (((intptr\_t) ret) & (WSIZE-1))));
00796         memcpy(ret, &aux, \textcolor{keyword}{sizeof}(BitMap));
00797 
00798         \textcolor{keywordtype}{char} * maps\_ptr = ((\textcolor{keywordtype}{char} *) ret) + \textcolor{keyword}{sizeof}(BitMap);
00799         ret->R = (NODETYPE *) (maps\_ptr + (WSIZE - (((intptr\_t) maps\_ptr) & (
      WSIZE-1))));
00800 
00801         \textcolor{keywordtype}{int} i, r;
00802         \textcolor{keywordflow}{for} (i = 0, r = 0; i < size; i++, r += tamRS)
00803                 memset(ret->R + r, 0, tamR<<LOGW);
00804         ret->minRNode = ret->R;
00805         ret->maxRNode = ret->R+ret->nRnodes;
00806 
00807         \textcolor{keywordflow}{return} ret;
00808 \}
00809 
00820 \textcolor{keyword}{static} \textcolor{keyword}{inline} BitMap * \textcolor{keyword}{const} newBitMap(\textcolor{keywordtype}{size\_t} n) \{
00821         \textcolor{keywordflow}{return} newBitMapVector(1, n);
00822 \}
00823 
00824 \textcolor{keyword}{static} \textcolor{keyword}{inline} BitMap * \textcolor{keyword}{const} similarBitMap(BitMap * \textcolor{keyword}{const} b) \{
00825         \textcolor{keywordflow}{return} newBitMap(b->n);
00826 \}
00827 
00835 \textcolor{keyword}{static} \textcolor{keyword}{inline} \textcolor{keywordtype}{void} copyAll(BitMap * bmvec, BitMap \textcolor{keyword}{const} * abmvec) \{
00836         memcpy(bmvec->minRNode, abmvec->minRNode, (abmvec->maxRNode-abmvec->minRNode) << 
      LOGW);
00837 \}
00838 
00847 \textcolor{keyword}{static} \textcolor{keyword}{inline} BitMap * \textcolor{keyword}{const} cloneBitMap(BitMap * \textcolor{keyword}{const} b) \{
00848         BitMap * ret = similarBitMap(b);
00849         copyAll(ret, b);
00850         \textcolor{keywordflow}{return} ret;
00851 \}
00852 
00853 \textcolor{keyword}{static} \textcolor{keyword}{inline} BitMap *newViewOf(BitMap * \textcolor{keyword}{const} bm) \{
00854         BitMap * ret = (BitMap *) malloc(WSIZE+\textcolor{keyword}{sizeof}(BitMap));
00855         \textcolor{keywordflow}{if} (ret==NULL)
00856                 \textcolor{keywordflow}{return}(NULL);
00857 
00858         ret =  (BitMap *) (((\textcolor{keywordtype}{char} *) ret) + (WSIZE - (((intptr\_t) ret) & (WSIZE-1))));
00859         memcpy(ret, bm, \textcolor{keyword}{sizeof}(BitMap));
00860         ret->ptr = (\textcolor{keywordtype}{char} *) ret;
00861         memset((\textcolor{keywordtype}{int} *) &ret->size, 1, \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{int}));
00862 
00863         \textcolor{keywordflow}{return} ret;
00864 \}
00865 
00866 \textcolor{keyword}{static} \textcolor{keyword}{inline} \textcolor{keywordtype}{void} setAsViewOf(BitMap * \textcolor{keyword}{const} bm, BitMap * v) \{
00867         \textcolor{keyword}{const} \textcolor{keywordtype}{char} * aux = v->ptr;
00868         memcpy(v, bm, \textcolor{keyword}{sizeof}(BitMap));
00869         v->ptr = aux;
00870         memset((\textcolor{keywordtype}{int} *) &v->size, 1, \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{int}));
00871 \}
00872 
00873 \textcolor{keyword}{static} \textcolor{keyword}{inline} \textcolor{keywordtype}{void} freeBitMap(BitMap *ptr) \{
00874         free((\textcolor{keywordtype}{char} *) ptr->ptr);
00875 \}
00876 
00877 \textcolor{keyword}{static} \textcolor{keyword}{inline} \textcolor{keywordtype}{void} subMap(BitMap * \textcolor{keyword}{const} bm, BitMap * r, \textcolor{keywordtype}{int} i) \{
00878         \textcolor{keywordtype}{int} is = (i<<bm->step);
00879         r->R = bm->R + is;
00880         r->minRNode = r->R;
00881         r->maxRNode = r->R+r->nRnodes;
00882 \}
00883 
00892 \textcolor{keyword}{static} \textcolor{keyword}{inline} \textcolor{keywordtype}{int} getElement(Node \textcolor{keyword}{const} * node) \{
00893         \textcolor{keywordflow}{return} node->nelem + node->cur;
00894 \}
00895 
00896 \textcolor{keyword}{static} \textcolor{keyword}{inline} \textcolor{keywordtype}{void} setElement(Node * node, \textcolor{keywordtype}{int} i) \{
00897         node->ind = NODEIDX(i);
00898         node->nelem = NELEM(node->ind);
00899         node->cur = IDXINNODE(i);
00900 \}
00901 
00911 \textcolor{keyword}{static} \textcolor{keyword}{inline} \textcolor{keywordtype}{void} delElement(BitMap * bm, Node \textcolor{keyword}{const} * i) \{
00912 \textcolor{preprocessor}{#if defined(\_ARCH8\_) || defined(\_ARCH32\_) || defined(\_ARCH64\_)}
00913         *(bm->R+i->ind) &= ~(ONE << (i->cur));
00914 \textcolor{preprocessor}{#elif defined(\_ARCH128\_) || defined(\_ARCH256\_)}
00915         (bm->R+i->ind)->ui64[(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}) \_\_index[i->cur]] &= ~\_\_oneshifted[i->
      cur];
00916 \textcolor{preprocessor}{#endif}
00917 \}
00918 
00928 \textcolor{keyword}{static} \textcolor{keyword}{inline} \textcolor{keywordtype}{void} addElement(BitMap * bm, Node \textcolor{keyword}{const} * i) \{
00929 \textcolor{preprocessor}{#if defined(\_ARCH8\_) || defined(\_ARCH32\_) || defined(\_ARCH64\_)}
00930         *(bm->R+i->ind) |= (ONE << (i->cur));
00931 \textcolor{preprocessor}{#elif defined(\_ARCH128\_) || defined(\_ARCH256\_)}
00932         (bm->R+i->ind)->ui64[(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}) \_\_index[i->cur]] |= \_\_oneshifted[i->
      cur];
00933 \textcolor{preprocessor}{#endif}
00934 \}
00935 
00945 \textcolor{keyword}{static} \textcolor{keyword}{inline} \textcolor{keywordtype}{void} invElement(BitMap * bm, Node \textcolor{keyword}{const} * i) \{
00946 \textcolor{preprocessor}{#if defined(\_ARCH8\_) || defined(\_ARCH32\_) || defined(\_ARCH64\_)}
00947         *(bm->R+i->ind) ^= (ONE << (i->cur));
00948 \textcolor{preprocessor}{#elif defined(\_ARCH128\_) || defined(\_ARCH256\_)}
00949         (bm->R+i->ind)->ui64[(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}) \_\_index[i->cur]] ^= \_\_oneshifted[i->
      cur];
00950 \textcolor{preprocessor}{#endif}
00951 \}
00952 
00962 \textcolor{keyword}{static} \textcolor{keyword}{inline} \textcolor{keywordtype}{int} hasElement(BitMap \textcolor{keyword}{const} * bm, \textcolor{keywordtype}{int} i) \{
00963 \textcolor{preprocessor}{#if defined(\_ARCH8\_) || defined(\_ARCH32\_) || defined(\_ARCH64\_)}
00964         \textcolor{keywordflow}{return} ISINNODE(*(bm->R+NODEIDX(i)), IDXINNODE(i)) != 0;
00965 \textcolor{preprocessor}{#elif defined(\_ARCH128\_) || defined(\_ARCH256\_)}
00966         \textcolor{keywordtype}{int} idx = IDXINNODE(i);
00967         \textcolor{keywordflow}{return} ISINNODE((bm->R+NODEIDX(i))->ui64[(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}) \_\_index[idx]], idx) != 0;
00968 \textcolor{preprocessor}{#endif}
00969 \}
00970 
00971 \textcolor{keyword}{static} \textcolor{keyword}{inline} BitMap * \textcolor{keyword}{const} pack(\textcolor{keywordtype}{int} * \textcolor{keyword}{const} v, \textcolor{keywordtype}{size\_t} sz, \textcolor{keywordtype}{size\_t} n) \{
00972         BitMap * ret = newBitMap(n);
00973         Node node;
00974         \textcolor{keywordtype}{int} i;
00975         \textcolor{keywordflow}{for} (i = 0; i < sz; i++) \{
00976                 setElement(&node, v[i]);
00977                 addElement(ret, &node);
00978         \}
00979         \textcolor{keywordflow}{return} ret;
00980 \}
00981 
00982 \textcolor{keyword}{static} \textcolor{keyword}{inline} \textcolor{keywordtype}{int} isEmpty(BitMap * mvec) \{
00983         NODETYPE * node = mvec->minRNode;
00984         \textcolor{keywordflow}{while} (node < mvec->maxRNode)
00985         \{
00986                 \textcolor{keywordflow}{if} (NODEISNOTEMPTY(*node))
00987                         \textcolor{keywordflow}{return} 0;
00988                 node++;
00989         \}
00990         \textcolor{keywordflow}{return} 1;
00991 \}
00992 
00993 \textcolor{keyword}{static} \textcolor{keyword}{inline} \textcolor{keywordtype}{int} isNotEmpty(BitMap * mvec) \{
00994         NODETYPE * node = mvec->minRNode;
00995         \textcolor{keywordflow}{while} (node < mvec->maxRNode)
00996         \{
00997                 \textcolor{keywordflow}{if} (NODEISNOTEMPTY(*node))
00998                         \textcolor{keywordflow}{return} 1;
00999                 node++;
01000         \}
01001         \textcolor{keywordflow}{return} 0;
01002 \}
01003 
01004 \textcolor{keyword}{static} \textcolor{keyword}{inline} \textcolor{keywordtype}{int} areEqual(BitMap * abmvec, BitMap \textcolor{keyword}{const} * bbmvec) \{
01005         NODETYPE * abnode;
01006         NODETYPE * bbnode;
01007         NODETYPE buf;
01008 
01009         abnode = abmvec->minRNode;
01010         bbnode = bbmvec->R;
01011 
01012         \textcolor{keywordflow}{while} (abnode < abmvec->maxRNode) \{
01013 \textcolor{preprocessor}{#if defined(\_ARCH8\_) || defined(\_ARCH32\_) || defined(\_ARCH64\_)}
01014                 buf = *abnode ^ *bbnode;
01015 \textcolor{preprocessor}{#elif defined(\_ARCH128\_)}
01016                 \_mm\_store\_si128 (&buf.mi, \_mm\_xor\_si128 (bbnode->mi, abnode->mi));
01017 \textcolor{preprocessor}{#elif defined(\_ARCH256\_)}
01018                 \_mm256\_store\_pd(&buf.d64, \_mm256\_xor\_pd(bbnode->md, abnode->md));
01019 \textcolor{preprocessor}{#endif}
01020                 \textcolor{keywordflow}{if} (NODEISNOTEMPTY(buf))
01021                         \textcolor{keywordflow}{return} 0;
01022                 abnode++;
01023                 bbnode++;
01024         \}
01025 
01026         \textcolor{keywordflow}{return} 1;
01027 \}
01028 
01029 \textcolor{comment}{// forward enumeration}
01030 
01031 \textcolor{keyword}{static} \textcolor{keyword}{inline} \textcolor{keywordtype}{void} beginWhile(BitMap \textcolor{keyword}{const} * bm, Node * node) \{
01032         node->ind = 0;
01033         node->nelem = 0;
01034         node->cur = -1;
01035         node->end1 = bm->maxRNode;
01036         node->buf1 = bm->R;
01037 \}
01038 
01039 \textcolor{keyword}{static} \textcolor{keyword}{inline} \textcolor{keywordtype}{void} nextCommon(BitMap \textcolor{keyword}{const} * bm, Node * node) \{
01040         NODETYPE * buf2 = bm->R+node->ind;
01041     NODETYPE buf;
01042 \textcolor{preprocessor}{#if defined(\_ARCH8\_) || defined(\_ARCH32\_) || defined(\_ARCH64\_)}
01043     buf = *node->buf1 & *buf2;
01044     node->cur = NODENEXTLEAST(buf, node->cur);
01045     \textcolor{keywordflow}{if} (node->cur < 0 && ++node->buf1 < node->end1)
01046     \{
01047         buf = *node->buf1 & *++buf2;
01048                 node->ind++;
01049                 node->nelem += BSIZE;
01050         \textcolor{keywordflow}{while} (buf == 0 && ++node->buf1 < node->end1)
01051         \{
01052             buf = *node->buf1 & *++buf2;
01053                 node->ind++;
01054                 node->nelem += BSIZE;
01055         \}
01056         node->cur = NODELEAST(buf);
01057     \}
01058 \textcolor{preprocessor}{#elif defined(\_ARCH128\_)}
01059     \_mm\_store\_si128 (&buf.mi, \_mm\_and\_si128 (buf2->mi, node->buf1->mi));
01060     node->cur = NODENEXTLEAST(buf, node->cur);
01061     \textcolor{keywordflow}{if} (node->cur < 0 && ++node->buf1 < node->end1)
01062     \{
01063         \_mm\_store\_si128 (&buf.mi, \_mm\_and\_si128 ((++buf2)->mi, node->buf1->mi));
01064                 node->ind++;
01065                 node->nelem += BSIZE;
01066         \textcolor{keywordflow}{while} (\_mm\_comieq\_ss(buf.m, \_\_zero.m) && ++node->buf1 < node->end1)
01067         \{
01068                 \_mm\_store\_si128 (&buf.mi, \_mm\_and\_si128 ((++buf2)->mi, node->
      buf1->mi));
01069                 node->ind++;
01070                 node->nelem += BSIZE;
01071         \}
01072         node->cur = NODELEAST(buf);
01073     \}
01074 \textcolor{preprocessor}{#elif defined(\_ARCH256\_)}
01075     \_mm256\_store\_pd(&buf.d64,\_mm256\_and\_pd(buf2->md, node->buf1->md));
01076     node->cur = NODENEXTLEAST(buf, node->cur);
01077     \textcolor{keywordflow}{if} (node->cur < 0 && ++node->buf1 < node->end1)
01078     \{
01079         \_mm256\_store\_pd(&buf.d64, \_mm256\_and\_pd((++buf2)->md, node->buf1->md));
01080                 node->ind++;
01081                 node->nelem += BSIZE;
01082         \textcolor{keywordflow}{while} (\_mm256\_testz\_si256(buf.mi, \_\_zero.mi) && ++node->buf1 < node->
      end1)
01083         \{
01084                 \_mm256\_store\_pd(&buf.d64, \_mm256\_and\_pd((++buf2)->md, node->buf1->md));
01085                 node->ind++;
01086                 node->nelem += BSIZE;
01087         \}
01088         node->cur = NODELEAST(buf);
01089     \}
01090 \textcolor{preprocessor}{#endif}
01091 \}
01092 
01093 \textcolor{keyword}{static} \textcolor{keyword}{inline} \textcolor{keywordtype}{void} beginCommon(BitMap \textcolor{keyword}{const} * abm, BitMap \textcolor{keyword}{const} * bm, Node * node) \{
01094         beginWhile(bm, node);
01095         nextCommon(abm, node);
01096 \}
01097 
01104 \textcolor{keyword}{static} \textcolor{keyword}{inline} \textcolor{keywordtype}{void} next(Node * node) \{
01105         node->cur = NODENEXTLEAST(*node->buf1, node->cur);
01106         \textcolor{keywordflow}{while} (node->cur < 0 && ++node->buf1 < node->end1) \{
01107                 node->ind++;
01108                 node->nelem += BSIZE;
01109                 node->cur = NODELEAST(*node->buf1);
01110         \}
01111 \}
01112 
01120 \textcolor{keyword}{static} \textcolor{keyword}{inline} \textcolor{keywordtype}{void} begin(BitMap \textcolor{keyword}{const} * bm, Node * node) \{
01121         beginWhile(bm, node);
01122         next(node);
01123 \}
01124 
01133 \textcolor{keyword}{static} \textcolor{keyword}{inline} \textcolor{keywordtype}{int} end(Node * node) \{
01134         \textcolor{keywordflow}{return} node->buf1 >= node->end1;
01135 \}
01136 
01137 \textcolor{keyword}{static} \textcolor{keyword}{inline} \textcolor{keywordtype}{void} copySets(Node * node, Node * anode) \{
01138         \textcolor{keywordtype}{int} d = (anode->end1-anode->buf1);
01139         node->buf1 = node->end1-d;
01140         node->ind = anode->ind;
01141         node->nelem = anode->nelem;
01142         node->cur = anode->cur;
01143         memcpy(node->buf1, anode->buf1, d << LOGW);
01144 \}
01145 
01146 \textcolor{comment}{// backward enumeration}
01147 
01148 \textcolor{keyword}{static} \textcolor{keyword}{inline} \textcolor{keywordtype}{void} rearWhile(BitMap \textcolor{keyword}{const} * bm, Node * node) \{
01149         node->ind = bm->nRnodes-1;
01150         node->nelem = NELEM(node->ind);
01151         node->cur = BSIZE;
01152         node->beg1 = bm->minRNode-1;
01153         node->buf1 = bm->maxRNode-1;
01154 \}
01155 
01156 \textcolor{keyword}{static} \textcolor{keyword}{inline} \textcolor{keywordtype}{void} prevCommon(BitMap \textcolor{keyword}{const} * bm, Node * node) \{
01157         NODETYPE * buf2 = bm->R+node->ind;
01158     NODETYPE buf;
01159 \textcolor{preprocessor}{#if defined(\_ARCH8\_) || defined(\_ARCH32\_) || defined(\_ARCH64\_)}
01160     buf = *node->buf1 & *buf2;
01161     node->cur = NODEPREVMOST(buf, node->cur);
01162     \textcolor{keywordflow}{if} (node->cur < 0 && --node->buf1 > node->beg1)
01163     \{
01164         buf = *node->buf1 & *--buf2;
01165                 node->ind--;
01166                 node->nelem -= BSIZE;
01167         \textcolor{keywordflow}{while} (buf == 0 && --node->buf1 > node->beg1)
01168         \{
01169             buf = *node->buf1 & *--buf2;
01170                 node->ind--;
01171                 node->nelem -= BSIZE;
01172         \}
01173         node->cur = NODEMOST(buf);
01174     \}
01175 \textcolor{preprocessor}{#elif defined (\_ARCH128\_)}
01176     \_mm\_store\_si128 (&buf.mi, \_mm\_and\_si128 (buf2->mi, node->buf1->mi));
01177     node->cur = NODEPREVMOST(buf, node->cur);
01178     \textcolor{keywordflow}{if} (node->cur < 0 && --node->buf1 > node->beg1)
01179     \{
01180         \_mm\_store\_si128 (&buf.mi, \_mm\_and\_si128 ((--buf2)->mi, node->buf1->mi));
01181                 node->ind--;
01182                 node->nelem -= BSIZE;
01183         \textcolor{keywordflow}{while} (\_mm\_comieq\_ss(buf.m, \_\_zero.m) && --node->buf1 > node->beg1)
01184         \{
01185                 \_mm\_store\_si128 (&buf.mi, \_mm\_and\_si128 ((--buf2)->mi, node->
      buf1->mi));
01186                 node->ind--;
01187                 node->nelem -= BSIZE;
01188         \}
01189         node->cur = NODEMOST(buf);
01190     \}
01191 \textcolor{preprocessor}{#elif defined (\_ARCH256\_)}
01192         \_mm256\_store\_pd(&buf.d64, \_mm256\_and\_pd(buf2->md, node->buf1->md));
01193     node->cur = NODEPREVMOST(buf, node->cur);
01194     \textcolor{keywordflow}{if} (node->cur < 0 && --node->buf1 > node->beg1)
01195     \{
01196         \_mm256\_store\_pd(&buf.d64, \_mm256\_and\_pd((--buf2)->md, node->buf1->md));
01197                 node->ind--;
01198                 node->nelem -= BSIZE;
01199         \textcolor{keywordflow}{while} (\_mm256\_testz\_si256(buf.mi, \_\_zero.mi) && --node->buf1 > node->
      beg1)
01200         \{
01201                 \_mm256\_store\_pd(&buf.d64,\_mm256\_and\_pd((--buf2)->md, node->buf1->md));
01202                 node->ind--;
01203                 node->nelem -= BSIZE;
01204         \}
01205         node->cur = NODEMOST(buf);
01206     \}
01207 \textcolor{preprocessor}{#endif}
01208 \}
01209 
01210 \textcolor{keyword}{static} \textcolor{keyword}{inline} \textcolor{keywordtype}{void} rearCommon(BitMap \textcolor{keyword}{const} * abm, BitMap \textcolor{keyword}{const} * bm, Node * node) \{
01211         rearWhile(bm, node);
01212         prevCommon(bm, node);
01213 \}
01214 
01215 \textcolor{keyword}{static} \textcolor{keyword}{inline} \textcolor{keywordtype}{void} prev(Node * node) \{
01216         node->cur = NODEPREVMOST(*node->buf1, node->cur);
01217         \textcolor{keywordflow}{while} (node->cur < 0 && --node->buf1 > node->beg1) \{
01218                 node->ind--;
01219                 node->nelem -= BSIZE;
01220                 node->cur = NODEMOST(*node->buf1);
01221         \}
01222 \}
01223 
01224 \textcolor{keyword}{static} \textcolor{keyword}{inline} \textcolor{keywordtype}{void} rear(BitMap \textcolor{keyword}{const} * bm, Node * node) \{
01225         rearWhile(bm, node);
01226         prev(node);
01227 \}
01228 
01229 \textcolor{keyword}{static} \textcolor{keyword}{inline} \textcolor{keywordtype}{int} head(Node * node) \{
01230         \textcolor{keywordflow}{return} node->buf1 <= node->beg1;
01231 \}
01232 
01233 \textcolor{keyword}{static} \textcolor{keyword}{inline} \textcolor{keywordtype}{void} getNode(Node * node, \textcolor{keywordtype}{int} i) \{
01234         node->ind = NODEIDX(i);
01235         node->nelem = NELEM(node->ind);
01236         node->cur = IDXINNODE(i);
01237 \}
01238 
01239 \textcolor{keyword}{static} \textcolor{keyword}{inline} \textcolor{keywordtype}{void} printNode(Node * node) \{
01240         printf(\textcolor{stringliteral}{"ind=%d  nelem=%d  cur=%d  elem=%d\(\backslash\)n"},node->ind, node->nelem, node->
      cur, node->nelem+ node->cur);
01241 \}
01242 
01251 \textcolor{keyword}{static} \textcolor{keyword}{inline} \textcolor{keywordtype}{int} cardOf(BitMap \textcolor{keyword}{const} * bmvec) \{
01252         \textcolor{keywordtype}{int} ret = 0;
01253         NODETYPE * node;
01254         \textcolor{keywordflow}{for} (node = bmvec->minRNode; node < bmvec->maxRNode; node++)
01255                 ret += NODECOUNTER(*node);
01256         \textcolor{keywordflow}{return} ret;
01257 \}
01258 
01259 \textcolor{keyword}{static} \textcolor{keyword}{inline} \textcolor{keywordtype}{int} * \textcolor{keyword}{const} unpack(BitMap * \textcolor{keyword}{const} b) \{
01260         \textcolor{keywordtype}{int} * ret = calloc(cardOf(b), \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{int}));
01261         Node node;
01262         \textcolor{keywordtype}{int} i;
01263         \textcolor{keywordflow}{for} (begin(b, &node), i=0; !end(&node); next(&node), i++) \{
01264                 ret[i]= getElement(&node);
01265         \}
01266         \textcolor{keywordflow}{return} ret;
01267 \}
01268 
01278 \textcolor{keyword}{static} \textcolor{keyword}{inline} \textcolor{keywordtype}{void} addAll(BitMap * bmvec, BitMap \textcolor{keyword}{const} * abmvec) \{
01279         NODETYPE * bnode;
01280         NODETYPE * abnode;
01281 
01282 \textcolor{preprocessor}{#if defined(\_ARCH8\_) || defined(\_ARCH32\_) || defined(\_ARCH64\_)}
01283         \textcolor{keywordflow}{for} (bnode = bmvec->R, abnode = abmvec->minRNode; abnode < abmvec->maxRNode; bnode++, abnode++)
01284                 *bnode |= *abnode;
01285 \textcolor{preprocessor}{#elif defined(\_ARCH128\_)}
01286         \textcolor{keywordflow}{for} (bnode = bmvec->R, abnode = abmvec->minRNode; abnode < abmvec->maxRNode; bnode++, abnode++)
01287                 \_mm\_store\_si128 (&bnode->mi, \_mm\_or\_si128 (bnode->mi, abnode->mi));
01288 \textcolor{preprocessor}{#elif defined(\_ARCH256\_)}
01289         \textcolor{keywordflow}{for} (bnode = bmvec->R, abnode = abmvec->minRNode; abnode < abmvec->maxRNode; bnode++, abnode++)
01290                 \_mm256\_store\_pd(&bnode->d64, \_mm256\_or\_pd(bnode->md, abnode->md));
01291 \textcolor{preprocessor}{#endif}
01292 \}
01293 
01294 \textcolor{keyword}{static} \textcolor{keyword}{inline} \textcolor{keywordtype}{void} moveAll(BitMap * bmvec, BitMap \textcolor{keyword}{const} * abmvec) \{
01295         NODETYPE * bnode;
01296         NODETYPE * abnode;
01297 
01298 \textcolor{preprocessor}{#if defined(\_ARCH8\_) || defined(\_ARCH32\_) || defined(\_ARCH64\_)}
01299         \textcolor{keywordflow}{for} (bnode = bmvec->R, abnode = abmvec->minRNode; abnode < abmvec->maxRNode; bnode++, abnode++) \{
01300                 *bnode |= *abnode;
01301                 *abnode = 0;
01302         \}
01303 \textcolor{preprocessor}{#elif defined(\_ARCH128\_)}
01304         \textcolor{keywordflow}{for} (bnode = bmvec->R, abnode = abmvec->minRNode; abnode < abmvec->maxRNode; bnode++, abnode++) \{
01305                 \_mm\_store\_si128 (&bnode->mi, \_mm\_or\_si128 (bnode->mi, abnode->mi));
01306                 \_mm\_store\_si128 (&abnode->mi, \_\_zero.mi);
01307         \}
01308 \textcolor{preprocessor}{#elif defined(\_ARCH256\_)}
01309         \textcolor{keywordflow}{for} (bnode = bmvec->R, abnode = abmvec->minRNode; abnode < abmvec->maxRNode; bnode++, abnode++) \{
01310                 \_mm256\_store\_pd (&bnode->d64, \_mm256\_or\_pd (bnode->md, abnode->md));
01311                 \_mm256\_store\_pd (&abnode->d64, \_\_zero.md);
01312         \}
01313 \textcolor{preprocessor}{#endif}
01314 \}
01315 
01316 \textcolor{keyword}{static} \textcolor{keyword}{inline} \textcolor{keywordtype}{void} addAllElements(BitMap * bm) \{
01317         memset(bm->R, 0xFF, (bm->nRnodes << LOGW));
01318         bm->maxRNode--;
01319 
01320 \textcolor{preprocessor}{#if defined(\_ARCH8\_) || defined(\_ARCH32\_) || defined(\_ARCH64\_)}
01321         *bm->maxRNode = RETAINLEAST(*bm->maxRNode,IDXINNODE(bm->n-1)+1);
01322 \textcolor{preprocessor}{#elif defined(\_ARCH128\_) || defined(\_ARCH256\_)}
01323         \textcolor{keywordtype}{int} idx = IDXINNODE(bm->n-1);
01324         bm->maxRNode->ui64[(\textcolor{keywordtype}{unsigned} int) \_\_index[idx]] = RETAINLEAST(bm->maxRNode->ui64[(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}) 
      \_\_index[idx]], idx-((\textcolor{keywordtype}{unsigned} int) \_\_index[idx] << LOGB)+1);
01325 \textcolor{preprocessor}{#endif}
01326 
01327         bm->maxRNode++;
01328 \}
01329 
01331 \textcolor{keyword}{static} \textcolor{keyword}{inline} \textcolor{keywordtype}{void} delAllElements(BitMap * bm) \{
01332         memset(bm->R, 0, (bm->nRnodes) << LOGW);
01333 \}
01334 
01344 \textcolor{keyword}{static} \textcolor{keyword}{inline} \textcolor{keywordtype}{void} removeAll(BitMap * bmvec, BitMap \textcolor{keyword}{const} * rbmvec) \{
01345         NODETYPE * bnode;
01346         NODETYPE * rbnode;
01347 
01348 \textcolor{preprocessor}{#if defined(\_ARCH8\_) || defined(\_ARCH32\_) || defined(\_ARCH64\_)}
01349         \textcolor{keywordflow}{for} (bnode = bmvec->minRNode, rbnode = rbmvec->R; bnode < bmvec->maxRNode; bnode++, rbnode++)
01350                 *bnode &= ~*rbnode;
01351 \textcolor{preprocessor}{#elif defined(\_ARCH128\_)}
01352         \textcolor{keywordflow}{for} (bnode = bmvec->minRNode, rbnode = rbmvec->R; bnode < bmvec->maxRNode; bnode++, rbnode++)
01353                 \_mm\_store\_si128 (&bnode->mi, \_mm\_andnot\_si128 (rbnode->mi, bnode->mi));
01354 \textcolor{preprocessor}{#elif defined(\_ARCH256\_)}
01355         \textcolor{keywordflow}{for} (bnode = bmvec->minRNode, rbnode = rbmvec->R; bnode < bmvec->maxRNode; bnode++, rbnode++)
01356                 \_mm256\_store\_pd(&bnode->d64,\_mm256\_andnot\_pd(rbnode->md, bnode->md));
01357 \textcolor{preprocessor}{#endif}
01358 \}
01359 
01360 \textcolor{keyword}{static} \textcolor{keyword}{inline} \textcolor{keywordtype}{void} removeFrom(Node * node, BitMap \textcolor{keyword}{const} * rbmvec) \{
01361         NODETYPE * bnode;
01362         NODETYPE * rbnode;
01363 
01364 \textcolor{preprocessor}{#if defined(\_ARCH8\_) || defined(\_ARCH32\_) || defined(\_ARCH64\_)}
01365         \textcolor{keywordflow}{for} (bnode = node->buf1, rbnode = rbmvec->R+node->ind; bnode < node->end1; bnode++, rbnode++)
01366                 *bnode &= ~*rbnode;
01367 \textcolor{preprocessor}{#elif defined(\_ARCH128\_)}
01368         \textcolor{keywordflow}{for} (bnode = node->buf1, rbnode = rbmvec->R+node->ind; bnode < node->end1; bnode++, rbnode++)
01369                 \_mm\_store\_si128 (&bnode->mi, \_mm\_andnot\_si128 (rbnode->mi, bnode->mi));
01370 \textcolor{preprocessor}{#elif defined(\_ARCH256\_)}
01371         \textcolor{keywordflow}{for} (bnode = node->buf1, rbnode = rbmvec->R+node->ind; bnode < node->end1; bnode++, rbnode++)
01372                 \_mm256\_store\_pd(&bnode->d64, \_mm256\_andnot\_pd(rbnode->md, bnode->md));
01373 \textcolor{preprocessor}{#endif}
01374 \}
01375 
01385 \textcolor{keyword}{static} \textcolor{keyword}{inline} \textcolor{keywordtype}{void} retainAll(BitMap * bmvec, BitMap \textcolor{keyword}{const} * rbmvec) \{
01386         NODETYPE * bnode;
01387         NODETYPE * rbnode;
01388 
01389 \textcolor{preprocessor}{#if defined(\_ARCH8\_) || defined(\_ARCH32\_) || defined(\_ARCH64\_)}
01390         \textcolor{keywordflow}{for} (bnode = bmvec->minRNode, rbnode = rbmvec->R; bnode < bmvec->maxRNode; bnode++, rbnode++)
01391                 *bnode &= *rbnode;
01392 \textcolor{preprocessor}{#elif defined(\_ARCH128\_)}
01393         \textcolor{keywordflow}{for} (bnode = bmvec->minRNode, rbnode = rbmvec->R; bnode < bmvec->maxRNode; bnode++, rbnode++)
01394                 \_mm\_store\_si128 (&bnode->mi, \_mm\_and\_si128 (rbnode->mi, bnode->mi));
01395 \textcolor{preprocessor}{#elif defined(\_ARCH256\_)}
01396         \textcolor{keywordflow}{for} (bnode = bmvec->minRNode, rbnode = rbmvec->R; bnode < bmvec->maxRNode; bnode++, rbnode++)
01397                 \_mm256\_store\_pd(&bnode->d64, \_mm256\_and\_pd(rbnode->md, bnode->md));
01398 \textcolor{preprocessor}{#endif}
01399 \}
01400 
01401 \textcolor{keyword}{static} \textcolor{keyword}{inline} \textcolor{keywordtype}{void} retainFrom(BitMap * bmvec, BitMap \textcolor{keyword}{const} * rbmvec, Node * node) \{
01402         NODETYPE * bnode;
01403         NODETYPE * rbnode;
01404 
01405 \textcolor{preprocessor}{#if defined(\_ARCH8\_) || defined(\_ARCH32\_) || defined(\_ARCH64\_)}
01406         \textcolor{keywordflow}{for} (bnode = node->buf1, rbnode = rbmvec->R+node->ind; bnode < bmvec->maxRNode; bnode++, rbnode++)
01407                 *bnode &= *rbnode;
01408 \textcolor{preprocessor}{#elif defined(\_ARCH128\_)}
01409         \textcolor{keywordflow}{for} (bnode = node->buf1, rbnode = rbmvec->R+node->ind; bnode < bmvec->maxRNode; bnode++, rbnode++)
01410                 \_mm\_store\_si128 (&bnode->mi, \_mm\_and\_si128 (rbnode->mi, bnode->mi));
01411 \textcolor{preprocessor}{#elif defined(\_ARCH256\_)}
01412         \textcolor{keywordflow}{for} (bnode = node->buf1, rbnode = rbmvec->R+node->ind; bnode < bmvec->maxRNode; bnode++, rbnode++)
01413                 \_mm256\_store\_pd(&bnode->d64, \_mm256\_and\_pd(rbnode->md, bnode->md));
01414 \textcolor{preprocessor}{#endif}
01415 \}
01416 
01427 \textcolor{keyword}{static} \textcolor{keyword}{inline} \textcolor{keywordtype}{void} symDiffOf(BitMap * bmvec, BitMap \textcolor{keyword}{const} * abmvec, BitMap \textcolor{keyword}{const} * bbmvec) \{
01428         NODETYPE * bnode;
01429         NODETYPE * abnode;
01430         NODETYPE * bbnode;
01431 
01432 \textcolor{preprocessor}{#if defined(\_ARCH8\_) || defined(\_ARCH32\_) || defined(\_ARCH64\_)}
01433         \textcolor{keywordflow}{for} (bnode = bmvec->minRNode, abnode = abmvec->minRNode, bbnode = bbmvec->minRNode; bnode < bmvec->
      maxRNode; bnode++, abnode++, bbnode++)
01434                 *bnode ^= *rbnode;
01435 \textcolor{preprocessor}{#elif defined(\_ARCH128\_)}
01436         \textcolor{keywordflow}{for} (bnode = bmvec->minRNode, abnode = abmvec->minRNode, bbnode = bbmvec->minRNode; bnode < bmvec->
      maxRNode; bnode++, abnode++, bbnode++)
01437                 \_mm\_store\_si128 (&bnode->mi, \_mm\_xor\_si128 (rbnode->mi, bnode->mi));
01438 \textcolor{preprocessor}{#elif defined(\_ARCH256\_)}
01439         \textcolor{keywordflow}{for} (bnode = bmvec->minRNode, abnode = abmvec->minRNode, bbnode = bbmvec->minRNode; bnode < bmvec->
      maxRNode; bnode++, abnode++, bbnode++)
01440                 \_mm256\_store\_pd(&bnode->d64, \_mm256\_xor\_pd(rbnode->md, bnode->md));
01441 \textcolor{preprocessor}{#endif}
01442 \}
01443 
01444 \textcolor{keyword}{static} \textcolor{keyword}{inline} \textcolor{keywordtype}{void} symDiffFrom(BitMap * bmvec, BitMap \textcolor{keyword}{const} * rbmvec, Node * node) \{
01445         NODETYPE * bnode;
01446         NODETYPE * rbnode;
01447 
01448 \textcolor{preprocessor}{#if defined(\_ARCH8\_) || defined(\_ARCH32\_) || defined(\_ARCH64\_)}
01449         \textcolor{keywordflow}{for} (bnode = node->buf1, rbnode = rbmvec->R+node->ind; bnode < bmvec->maxRNode; bnode++, rbnode++)
01450                 *bnode ^= *rbnode;
01451 \textcolor{preprocessor}{#elif defined(\_ARCH128\_)}
01452         \textcolor{keywordflow}{for} (bnode = node->buf1, rbnode = rbmvec->R+node->ind; bnode < bmvec->maxRNode; bnode++, rbnode++)
01453                 \_mm\_store\_si128 (&bnode->mi, \_mm\_xor\_si128 (rbnode->mi, bnode->mi));
01454 \textcolor{preprocessor}{#elif defined(\_ARCH256\_)}
01455         \textcolor{keywordflow}{for} (bnode = node->buf1, rbnode = rbmvec->R+node->ind; bnode < bmvec->maxRNode; bnode++, rbnode++)
01456                 \_mm256\_store\_pd(&bnode->d64, \_mm256\_xor\_pd(rbnode->md, bnode->md));
01457 \textcolor{preprocessor}{#endif}
01458 \}
01459 
01470 \textcolor{keyword}{static} \textcolor{keyword}{inline} \textcolor{keywordtype}{void} intersectOf(BitMap * bmvec, BitMap \textcolor{keyword}{const} * abmvec, BitMap \textcolor{keyword}{const} * bbmvec) \{
01471         NODETYPE * bnode;
01472         NODETYPE * abnode;
01473         NODETYPE * bbnode;
01474 
01475 \textcolor{preprocessor}{#if defined(\_ARCH8\_) || defined(\_ARCH32\_) || defined(\_ARCH64\_)}
01476         \textcolor{keywordflow}{for} (bnode = bmvec->minRNode, abnode = abmvec->minRNode, bbnode = bbmvec->minRNode; bnode < bmvec->
      maxRNode; bnode++, abnode++, bbnode++)
01477                 *bnode = *abnode & *bbnode;
01478 \textcolor{preprocessor}{#elif defined(\_ARCH128\_)}
01479         \textcolor{keywordflow}{for} (bnode = bmvec->minRNode, abnode = abmvec->minRNode, bbnode = bbmvec->minRNode; bnode < bmvec->
      maxRNode; bnode++, abnode++, bbnode++)
01480                 \_mm\_store\_si128 (&bnode->mi, \_mm\_and\_si128 (abnode->mi, bbnode->mi));
01481 \textcolor{preprocessor}{#elif defined(\_ARCH256\_)}
01482         \textcolor{keywordflow}{for} (bnode = bmvec->minRNode, abnode = abmvec->minRNode, bbnode = bbmvec->minRNode; bnode < bmvec->
      maxRNode; bnode++, abnode++, bbnode++)
01483                 \_mm256\_store\_pd(&bnode->d64, \_mm256\_and\_pd(abnode->md, bbnode->md));
01484 \textcolor{preprocessor}{#endif}
01485 \}
01486 
01495 \textcolor{keyword}{static} \textcolor{keyword}{inline} \textcolor{keywordtype}{int} isSubset(BitMap \textcolor{keyword}{const} * abmvec, BitMap \textcolor{keyword}{const} * bbmvec) \{
01496         NODETYPE * abnode;
01497         NODETYPE * bbnode;
01498 
01499 \textcolor{preprocessor}{#if defined(\_ARCH8\_) || defined(\_ARCH32\_) || defined(\_ARCH64\_)}
01500         \textcolor{keywordflow}{for} (abnode = abmvec->minRNode, bbnode = bbmvec->minRNode; abnode < abmvec->maxRNode && *abnode == 
      (*abnode & *bbnode); abnode++, bbnode++);
01501         \textcolor{keywordflow}{return} abnode == abmvec->maxRNode;
01502 \textcolor{preprocessor}{#elif defined(\_ARCH128\_)}
01503         \textcolor{keywordflow}{for} (abnode = abmvec->minRNode, bbnode = bbmvec->minRNode; abnode < abmvec->maxRNode && 
      \_mm\_comieq\_ss(abnode->m, (\_\_m128) \_mm\_and\_si128(abnode->mi, bbnode->mi)); abnode++, bbnode++);
01504         \textcolor{keywordflow}{return} abnode == abmvec->maxRNode;
01505 \textcolor{preprocessor}{#elif defined(\_ARCH256\_)}
01506         \textcolor{keywordflow}{for} (abnode = abmvec->minRNode, bbnode = bbmvec->minRNode; abnode < abmvec->maxRNode && 
      \_mm256\_testz\_si256(abnode->mi, (\_\_m256i) \_mm256\_and\_pd(abnode->md, bbnode->md)); abnode++, bbnode++);
01507         \textcolor{keywordflow}{return} abnode == abmvec->maxRNode;
01508 \textcolor{preprocessor}{#endif}
01509 \}
01510 
01524 \textcolor{keyword}{static} \textcolor{keyword}{inline} \textcolor{keywordtype}{void} * map(BitMap \textcolor{keyword}{const} * s, \textcolor{keywordtype}{void} * param, \textcolor{keywordtype}{void} *base, \textcolor{keywordtype}{size\_t} size,
01525         \textcolor{keywordtype}{void} (*f)(\textcolor{keywordtype}{void} *, \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long}, \textcolor{keywordtype}{void} *dest)) \{
01526         \textcolor{keywordtype}{int} i;
01527         Node node;
01528         \textcolor{keywordflow}{for} (begin(s, &node); !end(&node); next(&node)) \{
01529                 i = getElement(&node);
01530                 f(param,i,((\textcolor{keywordtype}{char} *) base)+(i*size));
01531         \}
01532 
01533         \textcolor{keywordflow}{return} base;
01534 \}
01535 
01536 \textcolor{keyword}{static} \textcolor{keyword}{inline} \textcolor{keywordtype}{void} * reduce(BitMap \textcolor{keyword}{const} * s, \textcolor{keywordtype}{void} * param, \textcolor{keywordtype}{void} *base,
01537         \textcolor{keywordtype}{void} (*f)(\textcolor{keywordtype}{void} *, \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long}, \textcolor{keywordtype}{void} *dest)) \{
01538         \textcolor{keywordtype}{int} i;
01539         Node node;
01540         \textcolor{keywordflow}{for} (begin(s, &node); !end(&node); next(&node))
01541                 f(param,getElement(&node),base);
01542 
01543         \textcolor{keywordflow}{return} base;
01544 \}
01545 
01546 \textcolor{keyword}{static} \textcolor{keyword}{inline} \textcolor{keywordtype}{void} printSetNodes(BitMap \textcolor{keyword}{const} * s) \{
01547         NODETYPE * node;
01548 
01549 \textcolor{preprocessor}{#ifdef \_ARCH32\_}
01550 \textcolor{preprocessor}{#define FORMX " %lx"}
01551 \textcolor{preprocessor}{#elif \_ARCH64\_}
01552 \textcolor{preprocessor}{#define FORMX " %llx"}
01553 \textcolor{preprocessor}{#elif \_ARCH128\_}
01554 \textcolor{preprocessor}{#define FORMX " %llx %llx"}
01555 \textcolor{preprocessor}{#elif \_ARCH256\_}
01556 \textcolor{preprocessor}{#define FORMX " %llx %llx %llx %llx"}
01557 \textcolor{preprocessor}{#else}
01558 \textcolor{preprocessor}{#define FORMX " %x"}
01559 \textcolor{preprocessor}{#endif}
01560 
01561         printf(\textcolor{stringliteral}{"SET: ["});
01562         \textcolor{keywordflow}{for} (node = s->R+NODEIDX(s->n-1); node >= s->R; node--)
01563 \textcolor{preprocessor}{#if defined(\_ARCH8\_) || defined(\_ARCH32\_) || defined(\_ARCH64\_)}
01564                 printf(FORMX, *node);
01565 \textcolor{preprocessor}{#elif defined(\_ARCH128\_)}
01566                 printf(FORMX, node->ui64[1], node->ui64[0]);
01567 \textcolor{preprocessor}{#elif defined(\_ARCH256\_)}
01568                 printf(FORMX, node->ui64[3], node->ui64[2], node->ui64[1], node->ui64[0]);
01569 \textcolor{preprocessor}{#endif}
01570         printf(\textcolor{stringliteral}{" ]\(\backslash\)n"});
01571 \}
01572 
01573 \textcolor{preprocessor}{#endif }\textcolor{comment}{/* BITMAP\_H\_ */}\textcolor{preprocessor}{}
\end{DoxyCode}
